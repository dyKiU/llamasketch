<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pencil Flux Klein</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #f5f5f5; color: #333; min-height: 100vh; display: flex; flex-direction: column; }

/* Header */
header { background: #1a1a2e; color: #fff; padding: 12px 24px; display: flex; justify-content: space-between; align-items: center; }
header h1 { font-size: 1.25rem; font-weight: 600; }
.status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
.status-dot.connected { background: #4caf50; }
.status-dot.disconnected { background: #f44336; }
.health-indicator { display: flex; align-items: center; font-size: 0.85rem; opacity: 0.9; }

/* Main layout */
main { display: flex; flex: 1; gap: 0; overflow: hidden; }
.panel { padding: 24px; overflow-y: auto; }
.panel-left { flex: 1; border-right: 1px solid #ddd; background: #fff; min-width: 0; }
.panel-right { flex: 1; background: #fafafa; min-width: 0; display: flex; flex-direction: column; }

/* Section labels */
.section-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #888; margin-bottom: 8px; font-weight: 600; }

/* Mode tabs */
.mode-tabs { display: flex; gap: 0; margin-bottom: 16px; border-bottom: 2px solid #eee; }
.mode-tab { padding: 8px 16px; border: none; background: none; cursor: pointer; font-size: 0.85rem; font-weight: 500; color: #888; border-bottom: 2px solid transparent; margin-bottom: -2px; transition: all 0.15s; }
.mode-tab:hover { color: #555; }
.mode-tab.active { color: #1a1a2e; border-bottom-color: #1a1a2e; font-weight: 600; }
.mode-content { display: none; }
.mode-content.active { display: block; }

/* Image preview areas */
.preview-container { width: 100%; max-width: 400px; aspect-ratio: 1; background: #eee; border: 2px dashed #ccc; border-radius: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-bottom: 16px; position: relative; }
.preview-container img { max-width: 100%; max-height: 100%; object-fit: contain; }
.preview-container.has-image { border-style: solid; border-color: #bbb; }
.preview-placeholder { color: #aaa; font-size: 0.9rem; }

/* Sketch preset buttons */
.sketch-presets { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
.sketch-presets button { padding: 8px 16px; border: 1px solid #ddd; border-radius: 6px; background: #fff; cursor: pointer; font-size: 0.85rem; transition: all 0.15s; }
.sketch-presets button:hover { border-color: #999; background: #f0f0f0; }
.sketch-presets button.active { border-color: #1a1a2e; background: #1a1a2e; color: #fff; }

/* Upload area */
.upload-area { margin-bottom: 16px; }
.upload-btn { position: relative; overflow: hidden; padding: 8px 16px; border: 1px solid #ddd; border-radius: 6px; background: #fff; cursor: pointer; font-size: 0.85rem; transition: all 0.15s; }
.upload-btn:hover { border-color: #999; background: #f0f0f0; }
.upload-btn input[type="file"] { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

/* Form controls */
.form-group { margin-bottom: 16px; }
.form-group label { display: block; font-size: 0.85rem; font-weight: 500; margin-bottom: 4px; }
.form-group input[type="text"],
.form-group textarea { width: 100%; max-width: 400px; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9rem; font-family: inherit; }
.form-group textarea { resize: vertical; min-height: 60px; }
.range-row { display: flex; align-items: center; gap: 12px; max-width: 400px; }
.range-row input[type="range"] { flex: 1; }
.range-value { font-size: 0.9rem; font-weight: 600; min-width: 24px; text-align: center; }

/* Checkbox */
.checkbox-row { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.85rem; font-weight: 500; }
.checkbox-row input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }

/* Generate button */
.generate-btn { padding: 10px 32px; background: #1a1a2e; color: #fff; border: none; border-radius: 6px; font-size: 0.95rem; font-weight: 500; cursor: pointer; transition: background 0.15s; }
.generate-btn:hover { background: #16213e; }
.generate-btn:disabled { background: #999; cursor: not-allowed; }

/* Status text */
.status-text { font-size: 0.85rem; color: #666; margin-top: 12px; }
.status-text.error { color: #d32f2f; }

/* Output panel */
.output-area { flex: 1; display: flex; flex-direction: column; }
.output-preview { width: 100%; max-width: 400px; aspect-ratio: 1; background: #eee; border: 2px solid #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-bottom: 12px; }
.output-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }

/* Progress bar */
.progress-bar-container { width: 100%; max-width: 400px; height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden; margin-bottom: 8px; display: none; }
.progress-bar-container.active { display: block; }
.progress-bar-fill { height: 100%; background: #1a1a2e; border-radius: 3px; transition: width 0.4s ease; width: 0%; }

/* History strip */
.history-strip { border-top: 1px solid #ddd; background: #fff; padding: 12px 24px; }
.history-strip .section-label { margin-bottom: 8px; }
.history-scroll { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px; }
.history-thumb { width: 64px; height: 64px; border-radius: 4px; border: 2px solid #ddd; overflow: hidden; cursor: pointer; flex-shrink: 0; transition: border-color 0.15s; }
.history-thumb:hover { border-color: #1a1a2e; }
.history-thumb img { width: 100%; height: 100%; object-fit: cover; }
.history-empty { color: #aaa; font-size: 0.85rem; }

/* Lightbox overlay */
.lightbox { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 100; cursor: pointer; }
.lightbox img { max-width: 90vw; max-height: 90vh; object-fit: contain; border-radius: 8px; }

/* Live Sketch canvas */
.canvas-wrapper { width: 100%; max-width: 400px; margin-bottom: 12px; }
.canvas-wrapper canvas { width: 100%; aspect-ratio: 1; border: 2px solid #bbb; border-radius: 8px; cursor: crosshair; touch-action: none; background: #fff; display: block; }
.canvas-toolbar { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; max-width: 400px; }
.tool-btn { padding: 6px 12px; border: 1px solid #ddd; border-radius: 6px; background: #fff; cursor: pointer; font-size: 0.8rem; transition: all 0.15s; }
.tool-btn:hover { border-color: #999; background: #f0f0f0; }
.tool-btn.active { border-color: #1a1a2e; background: #1a1a2e; color: #fff; }
.canvas-toolbar .range-row { flex: 1; min-width: 120px; }
.queue-status { font-size: 0.8rem; color: #888; margin-top: 4px; }

/* Responsive */
@media (max-width: 768px) {
  main { flex-direction: column; }
  .panel-left { border-right: none; border-bottom: 1px solid #ddd; }
  .preview-container, .output-preview, .form-group input, .form-group textarea, .canvas-wrapper { max-width: 100%; }
}
</style>
</head>
<body>

<header>
  <h1>Pencil Flux Klein</h1>
  <div class="health-indicator">
    <span class="status-dot disconnected" id="healthDot"></span>
    <span id="healthText">Checking...</span>
  </div>
</header>

<main>
  <div class="panel panel-left">
    <div class="section-label">Input Sketch</div>

    <div class="mode-tabs">
      <button class="mode-tab active" data-mode="presets">Presets</button>
      <button class="mode-tab" data-mode="upload">Upload</button>
      <button class="mode-tab" data-mode="live">Live Sketch</button>
    </div>

    <!-- Presets mode -->
    <div class="mode-content active" id="modePresets">
      <div class="preview-container" id="sketchPreview">
        <span class="preview-placeholder">Select a sketch below</span>
      </div>
      <div class="sketch-presets" id="sketchPresets">
        <!-- Populated by JS -->
      </div>
    </div>

    <!-- Upload mode -->
    <div class="mode-content" id="modeUpload">
      <div class="preview-container" id="uploadPreview">
        <span class="preview-placeholder">Upload an image</span>
      </div>
      <div class="upload-area">
        <button class="upload-btn" id="uploadBtn">
          Choose file...
          <input type="file" id="fileInput" accept="image/*">
        </button>
      </div>
    </div>

    <!-- Live Sketch mode -->
    <div class="mode-content" id="modeLive">
      <div class="canvas-wrapper">
        <canvas id="sketchCanvas" width="512" height="512"></canvas>
      </div>
      <div class="canvas-toolbar">
        <button class="tool-btn active" id="pencilBtn" data-tool="pencil">Pencil</button>
        <button class="tool-btn" id="eraserBtn" data-tool="eraser">Eraser</button>
        <div class="range-row">
          <input type="range" id="strokeWidthInput" min="1" max="30" value="3">
          <span class="range-value" id="strokeWidthValue">3</span>
        </div>
        <button class="tool-btn" id="clearCanvasBtn">Clear</button>
      </div>
      <div class="queue-status" id="queueStatus"></div>
    </div>

    <!-- Shared controls (hidden in live mode) -->
    <div id="sharedControls">
      <div class="form-group">
        <label for="promptInput">Prompt</label>
        <textarea id="promptInput" placeholder="Describe the image you want..."></textarea>
      </div>

      <div class="form-group">
        <label>Steps</label>
        <div class="range-row">
          <input type="range" id="stepsInput" min="1" max="50" value="4">
          <span class="range-value" id="stepsValue">4</span>
        </div>
      </div>

      <div class="form-group">
        <label>Creativity (low = faithful to sketch, high = more creative)</label>
        <div class="range-row">
          <input type="range" id="denoiseInput" min="0" max="100" value="75" step="5">
          <span class="range-value" id="denoiseValue">0.75</span>
        </div>
      </div>

      <div class="form-group" id="hdGroup">
        <label class="checkbox-row">
          <input type="checkbox" id="hdToggle">
          <span>HD mode <small style="color:#888">(two-pass: 512 then upscale to 1024)</small></span>
        </label>
      </div>

      <button class="generate-btn" id="generateBtn" disabled>Generate</button>
      <div class="status-text" id="statusText"></div>
    </div>
  </div>

  <div class="panel panel-right">
    <div class="section-label">Output</div>
    <div class="output-area">
      <div class="output-preview" id="outputPreview">
        <span class="preview-placeholder">Result will appear here</span>
      </div>
      <div class="progress-bar-container" id="progressBar">
        <div class="progress-bar-fill" id="progressFill"></div>
      </div>
      <div class="status-text" id="outputStatus"></div>
    </div>
  </div>
</main>

<div class="history-strip">
  <div class="section-label">History</div>
  <div class="history-scroll" id="historyScroll">
    <span class="history-empty" id="historyEmpty">No generations yet</span>
  </div>
</div>

<script>
const $ = (sel) => document.querySelector(sel);
const API = '';

// ========================================================================
// State
// ========================================================================
let selectedSketch = null;   // preset id string
let uploadedBase64 = null;   // base64 string for uploaded image
let polling = null;
let currentMode = 'presets'; // 'presets' | 'upload' | 'live'

// ========================================================================
// Queue Manager (synced copy of src/queue-manager.ts logic)
// ========================================================================
const MAX_QUEUE = 3;

function createQueue() {
  return { submissions: [], sequenceNumber: 0 };
}

function queueAddSubmission(queue, jobId) {
  queue.sequenceNumber++;
  const entry = { jobId, seqNum: queue.sequenceNumber, status: 'polling', pollTimer: null };
  let evicted = null;
  if (queue.submissions.length >= MAX_QUEUE) {
    queue.submissions.sort((a, b) => a.seqNum - b.seqNum);
    evicted = queue.submissions.shift();
  }
  queue.submissions.push(entry);
  return { entry, evicted };
}

function queueShouldDisplay(queue, entry) {
  if (entry.status !== 'completed') return false;
  return !queue.submissions.some(e => e.seqNum > entry.seqNum && e.status === 'completed');
}

function queueFindEntry(queue, jobId) {
  return queue.submissions.find(e => e.jobId === jobId);
}

function queueActiveCount(queue) {
  return queue.submissions.filter(e => e.status === 'pending' || e.status === 'polling').length;
}

const liveQueue = createQueue();

// ========================================================================
// Canvas Tools (synced copy of src/canvas-tools.ts logic)
// ========================================================================
let toolState = { tool: 'pencil', strokeWidth: 3 };

function getStrokeColor() {
  return toolState.tool === 'eraser' ? '#ffffff' : '#000000';
}

function toCanvasCoords(cssX, cssY, cssWidth, cssHeight, canvasWidth, canvasHeight) {
  return { x: (cssX / cssWidth) * canvasWidth, y: (cssY / cssHeight) * canvasHeight };
}

// ========================================================================
// Health check
// ========================================================================
async function checkHealth() {
  try {
    const res = await fetch(`${API}/api/health`);
    const data = await res.json();
    const dot = $('#healthDot');
    const text = $('#healthText');
    if (data.comfyui_reachable) {
      dot.className = 'status-dot connected';
      text.textContent = 'Connected';
    } else {
      dot.className = 'status-dot disconnected';
      text.textContent = 'Disconnected';
    }
  } catch {
    $('#healthDot').className = 'status-dot disconnected';
    $('#healthText').textContent = 'Backend offline';
  }
}

// ========================================================================
// Mode tabs
// ========================================================================
document.querySelectorAll('.mode-tab').forEach(tab => {
  tab.addEventListener('click', () => switchMode(tab.dataset.mode));
});

function switchMode(mode) {
  currentMode = mode;
  // Update tab highlight
  document.querySelectorAll('.mode-tab').forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
  // Show/hide mode content
  document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
  if (mode === 'presets') $('#modePresets').classList.add('active');
  else if (mode === 'upload') $('#modeUpload').classList.add('active');
  else if (mode === 'live') $('#modeLive').classList.add('active');

  // In live mode: hide shared controls (generate btn, HD toggle, etc.)
  const shared = $('#sharedControls');
  if (mode === 'live') {
    shared.style.display = 'none';
  } else {
    shared.style.display = '';
  }
}

// ========================================================================
// Load sketch presets
// ========================================================================
async function loadSketches() {
  try {
    const res = await fetch(`${API}/api/sketches`);
    const sketches = await res.json();
    const container = $('#sketchPresets');
    container.innerHTML = '';

    for (const s of sketches) {
      const btn = document.createElement('button');
      btn.textContent = s.name;
      btn.dataset.id = s.id;
      btn.dataset.prompt = s.default_prompt;
      btn.addEventListener('click', () => selectPreset(s.id, s.default_prompt));
      container.appendChild(btn);
    }
  } catch (e) {
    console.error('Failed to load sketches:', e);
  }
}

async function selectPreset(id, defaultPrompt) {
  selectedSketch = id;
  uploadedBase64 = null;

  // Highlight active button
  document.querySelectorAll('.sketch-presets button').forEach(b => {
    b.classList.toggle('active', b.dataset.id === id);
  });

  // Load preview image
  try {
    const res = await fetch(`${API}/api/sketches/${id}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    showSketchPreview(url);
  } catch (e) {
    console.error('Failed to load sketch:', e);
  }

  // Fill prompt
  $('#promptInput').value = defaultPrompt;
  $('#generateBtn').disabled = false;
}

// ========================================================================
// Upload handling
// ========================================================================
$('#fileInput').addEventListener('change', handleUpload);

function handleUpload(e) {
  const file = e.target.files[0];
  if (!file) return;

  selectedSketch = null;
  document.querySelectorAll('.sketch-presets button').forEach(b => b.classList.remove('active'));

  const reader = new FileReader();
  reader.onload = () => {
    const dataUrl = reader.result;
    uploadedBase64 = dataUrl.split(',')[1];
    // Show in upload preview
    const container = $('#uploadPreview');
    container.innerHTML = '';
    container.classList.add('has-image');
    const img = document.createElement('img');
    img.src = dataUrl;
    container.appendChild(img);
    $('#generateBtn').disabled = false;
  };
  reader.readAsDataURL(file);
}

function showSketchPreview(src) {
  const container = $('#sketchPreview');
  container.innerHTML = '';
  container.classList.add('has-image');
  const img = document.createElement('img');
  img.src = src;
  container.appendChild(img);
}

// ========================================================================
// Sliders
// ========================================================================
$('#stepsInput').addEventListener('input', (e) => {
  $('#stepsValue').textContent = e.target.value;
});
$('#denoiseInput').addEventListener('input', (e) => {
  $('#denoiseValue').textContent = (e.target.value / 100).toFixed(2);
});
$('#strokeWidthInput').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  toolState.strokeWidth = Math.max(1, Math.min(30, val));
  $('#strokeWidthValue').textContent = toolState.strokeWidth;
});

// ========================================================================
// Progress bar
// ========================================================================
const STATUS_PROGRESS = {
  queued: 10, uploading: 25, submitted: 40, processing: 60, downloading: 85, completed: 100,
};

function setProgress(status) {
  const container = $('#progressBar');
  const fill = $('#progressFill');
  const pct = STATUS_PROGRESS[status];
  if (pct !== undefined) {
    container.classList.add('active');
    fill.style.width = pct + '%';
  }
  if (status === 'completed' || status === 'failed' || status === 'cancelled') {
    // Hide after a short delay so the 100% state is visible
    setTimeout(() => {
      container.classList.remove('active');
      fill.style.width = '0%';
    }, status === 'completed' ? 600 : 0);
  }
}

// ========================================================================
// Generate (presets/upload modes)
// ========================================================================
$('#generateBtn').addEventListener('click', startGeneration);

async function startGeneration() {
  const sketch = uploadedBase64 || selectedSketch;
  if (!sketch) return;

  const prompt = $('#promptInput').value.trim() || undefined;
  const steps = parseInt($('#stepsInput').value);
  const denoise = parseInt($('#denoiseInput').value) / 100;
  const hd = $('#hdToggle').checked;

  const btn = $('#generateBtn');
  btn.disabled = true;
  btn.textContent = 'Generating...';
  $('#statusText').textContent = '';
  $('#statusText').className = 'status-text';
  $('#outputStatus').textContent = '';
  $('#outputStatus').className = 'status-text';

  // Clear output and show progress
  const outputContainer = $('#outputPreview');
  outputContainer.innerHTML = '<span class="preview-placeholder">Generating...</span>';
  setProgress('queued');

  try {
    const res = await fetch(`${API}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sketch, prompt, steps, denoise, hd }),
    });

    if (!res.ok) {
      const err = await res.json();
      throw new Error(err.detail || 'Generation failed');
    }

    const data = await res.json();
    pollJob(data.job_id);
  } catch (e) {
    btn.disabled = false;
    btn.textContent = 'Generate';
    $('#statusText').textContent = `Error: ${e.message}`;
    $('#statusText').className = 'status-text error';
  }
}

function pollJob(jobId) {
  if (polling) clearInterval(polling);

  polling = setInterval(async () => {
    try {
      const res = await fetch(`${API}/api/status/${jobId}`);
      const data = await res.json();
      const elapsed = data.elapsed_seconds ? `${data.elapsed_seconds}s` : '';
      $('#outputStatus').textContent = `Status: ${data.status}${elapsed ? ` (${elapsed})` : ''}`;
      setProgress(data.status);

      if (data.status === 'completed') {
        clearInterval(polling);
        polling = null;
        showResult(jobId, elapsed);
        $('#generateBtn').disabled = false;
        $('#generateBtn').textContent = 'Generate';
      } else if (data.status === 'failed') {
        clearInterval(polling);
        polling = null;
        $('#outputStatus').textContent = `Failed: ${data.error || 'Unknown error'} (${elapsed})`;
        $('#outputStatus').className = 'status-text error';
        $('#outputPreview').innerHTML = '<span class="preview-placeholder">Generation failed</span>';
        $('#generateBtn').disabled = false;
        $('#generateBtn').textContent = 'Generate';
      }
    } catch (e) {
      clearInterval(polling);
      polling = null;
      $('#outputStatus').textContent = 'Error polling status';
      $('#outputStatus').className = 'status-text error';
      $('#generateBtn').disabled = false;
      $('#generateBtn').textContent = 'Generate';
    }
  }, 1000);
}

async function showResult(jobId, elapsed) {
  try {
    const res = await fetch(`${API}/api/result/${jobId}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    // Show in output area
    const container = $('#outputPreview');
    container.innerHTML = '';
    const img = document.createElement('img');
    img.src = url;
    container.appendChild(img);

    $('#outputStatus').textContent = `Completed (${elapsed})`;

    // Add to history
    addToHistory(url);
  } catch (e) {
    $('#outputStatus').textContent = 'Error loading result';
    $('#outputStatus').className = 'status-text error';
  }
}

function addToHistory(imageUrl) {
  const empty = $('#historyEmpty');
  if (empty) empty.remove();

  const scroll = $('#historyScroll');
  const thumb = document.createElement('div');
  thumb.className = 'history-thumb';
  const img = document.createElement('img');
  img.src = imageUrl;
  thumb.appendChild(img);
  thumb.addEventListener('click', () => openLightbox(imageUrl));
  scroll.prepend(thumb);
}

function openLightbox(src) {
  const overlay = document.createElement('div');
  overlay.className = 'lightbox';
  const img = document.createElement('img');
  img.src = src;
  overlay.appendChild(img);
  overlay.addEventListener('click', () => overlay.remove());
  document.body.appendChild(overlay);
}

// ========================================================================
// Canvas drawing engine
// ========================================================================
const canvas = $('#sketchCanvas');
const ctx = canvas.getContext('2d');
let isDrawing = false;
let debounceTimer = null;
let hasStrokes = false;

// Init canvas to white
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, 512, 512);

// Tool buttons
$('#pencilBtn').addEventListener('click', () => {
  toolState.tool = 'pencil';
  $('#pencilBtn').classList.add('active');
  $('#eraserBtn').classList.remove('active');
});
$('#eraserBtn').addEventListener('click', () => {
  toolState.tool = 'eraser';
  $('#eraserBtn').classList.add('active');
  $('#pencilBtn').classList.remove('active');
});
$('#clearCanvasBtn').addEventListener('click', () => {
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, 512, 512);
  hasStrokes = false;
  updateQueueStatus();
});

function getCanvasPoint(e) {
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;
  if (e.touches) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  return toCanvasCoords(
    clientX - rect.left, clientY - rect.top,
    rect.width, rect.height,
    512, 512
  );
}

function startStroke(e) {
  e.preventDefault();
  isDrawing = true;
  const pt = getCanvasPoint(e);
  ctx.beginPath();
  ctx.moveTo(pt.x, pt.y);
  ctx.strokeStyle = getStrokeColor();
  ctx.lineWidth = toolState.strokeWidth;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
}

function continueStroke(e) {
  if (!isDrawing) return;
  e.preventDefault();
  const pt = getCanvasPoint(e);
  ctx.lineTo(pt.x, pt.y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(pt.x, pt.y);
}

function endStroke(e) {
  if (!isDrawing) return;
  e.preventDefault();
  isDrawing = false;
  hasStrokes = true;
  // Debounce submission
  if (debounceTimer) clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    if (currentMode === 'live' && hasStrokes) {
      submitCanvasToQueue();
    }
  }, 300);
}

// Mouse events
canvas.addEventListener('mousedown', startStroke);
canvas.addEventListener('mousemove', continueStroke);
canvas.addEventListener('mouseup', endStroke);
canvas.addEventListener('mouseleave', endStroke);

// Touch events
canvas.addEventListener('touchstart', startStroke, { passive: false });
canvas.addEventListener('touchmove', continueStroke, { passive: false });
canvas.addEventListener('touchend', endStroke, { passive: false });
canvas.addEventListener('touchcancel', endStroke, { passive: false });

// ========================================================================
// Live queue submission
// ========================================================================
async function submitCanvasToQueue() {
  // Get canvas as base64
  const dataUrl = canvas.toDataURL('image/png');
  const base64 = dataUrl.split(',')[1];

  const prompt = $('#promptInput')?.value?.trim() || undefined;

  try {
    const res = await fetch(`${API}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sketch: base64, prompt, steps: 4, denoise: 0.75, hd: false }),
    });

    if (!res.ok) {
      console.error('Live submit failed:', res.status);
      return;
    }

    const data = await res.json();
    const { entry, evicted } = queueAddSubmission(liveQueue, data.job_id);

    // Cancel evicted job (fire-and-forget)
    if (evicted) {
      if (evicted.pollTimer) clearInterval(evicted.pollTimer);
      fetch(`${API}/api/cancel/${evicted.jobId}`, { method: 'POST' }).catch(() => {});
    }

    // Start polling this job
    entry.pollTimer = setInterval(() => pollLiveJob(entry), 1000);
    updateQueueStatus();
  } catch (e) {
    console.error('Live submit error:', e);
  }
}

async function pollLiveJob(entry) {
  try {
    const res = await fetch(`${API}/api/status/${entry.jobId}`);
    const data = await res.json();

    setProgress(data.status);

    if (data.status === 'completed') {
      entry.status = 'completed';
      if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }

      if (queueShouldDisplay(liveQueue, entry)) {
        await showLiveResult(entry.jobId);
      }
      updateQueueStatus();
    } else if (data.status === 'failed' || data.status === 'cancelled') {
      entry.status = data.status;
      if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }
      updateQueueStatus();
    }
  } catch (e) {
    entry.status = 'failed';
    if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }
    updateQueueStatus();
  }
}

async function showLiveResult(jobId) {
  try {
    const res = await fetch(`${API}/api/result/${jobId}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    const container = $('#outputPreview');
    container.innerHTML = '';
    const img = document.createElement('img');
    img.src = url;
    container.appendChild(img);

    $('#outputStatus').textContent = 'Live result';
    $('#outputStatus').className = 'status-text';

    addToHistory(url);
  } catch (e) {
    console.error('Error loading live result:', e);
  }
}

function updateQueueStatus() {
  const count = queueActiveCount(liveQueue);
  const el = $('#queueStatus');
  if (count > 0) {
    el.textContent = `${count} generation${count > 1 ? 's' : ''} in queue`;
  } else if (hasStrokes) {
    el.textContent = 'Draw to generate';
  } else {
    el.textContent = '';
  }
}

// ========================================================================
// Init
// ========================================================================
checkHealth();
setInterval(checkHealth, 30000);
loadSketches();
</script>
</body>
</html>
