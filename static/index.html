<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pencil Flux Klein</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/* Theme variables */
:root {
  --bg: #f5f5f5;
  --panel-bg: #fff;
  --panel-alt: #fafafa;
  --text: #333;
  --text-muted: #888;
  --border: #ddd;
  --input-bg: #fff;
  --preview-bg: #eee;
  --accent: #1a1a2e;
  --accent-hover: #16213e;
}
body.dark {
  --bg: #1a1a1a;
  --panel-bg: #2a2a2e;
  --panel-alt: #232327;
  --text: #e0e0e0;
  --text-muted: #999;
  --border: #444;
  --input-bg: #333;
  --preview-bg: #333;
  --accent: #6c7bff;
  --accent-hover: #8b97ff;
}

body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; display: flex; flex-direction: column; }

/* Header */
header { background: var(--accent); color: #fff; padding: 12px 24px; display: flex; justify-content: space-between; align-items: center; }
header h1 { font-size: 1.25rem; font-weight: 600; }
.header-right { display: flex; align-items: center; gap: 16px; }
.theme-toggle { background: none; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: #fff; cursor: pointer; font-size: 1.1rem; padding: 4px 8px; line-height: 1; transition: border-color 0.15s; }
.theme-toggle:hover { border-color: rgba(255,255,255,0.6); }
.status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
.status-dot.connected { background: #4caf50; }
.status-dot.disconnected { background: #f44336; }
.health-indicator { display: flex; align-items: center; font-size: 0.85rem; opacity: 0.9; }

/* Main layout */
main { display: flex; flex: 1; gap: 0; overflow: hidden; align-items: flex-start; }
.panel { padding: 24px; overflow-y: auto; max-height: 100%; }
.panel-left { flex: 1; border-right: 1px solid var(--border); background: var(--panel-bg); min-width: 0; }
.panel-right { flex: 1; background: var(--panel-alt); min-width: 0; display: flex; flex-direction: column; }

/* Section labels */
.section-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 8px; font-weight: 600; }

/* Mode tabs */
.mode-tabs { display: flex; gap: 0; margin-bottom: 16px; border-bottom: 2px solid var(--border); }
.mode-tab { padding: 8px 16px; border: none; background: none; cursor: pointer; font-size: 0.85rem; font-weight: 500; color: var(--text-muted); border-bottom: 2px solid transparent; margin-bottom: -2px; transition: all 0.15s; }
.mode-tab:hover { color: var(--text); }
.mode-tab.active { color: var(--accent); border-bottom-color: var(--accent); font-weight: 600; }
.mode-content { display: none; }
.mode-content.active { display: block; }

/* Image preview areas */
.preview-container { width: 100%; max-width: 400px; aspect-ratio: 1; background: var(--preview-bg); border: 2px dashed var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-bottom: 16px; position: relative; }
.preview-container img { max-width: 100%; max-height: 100%; object-fit: contain; }
.preview-container.has-image { border-style: solid; border-color: var(--border); }
.preview-placeholder { color: var(--text-muted); font-size: 0.9rem; }

/* Sketch preset buttons */
.sketch-presets { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
.sketch-presets button { padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; background: var(--input-bg); color: var(--text); cursor: pointer; font-size: 0.85rem; transition: all 0.15s; }
.sketch-presets button:hover { border-color: var(--text-muted); background: var(--preview-bg); }
.sketch-presets button.active { border-color: var(--accent); background: var(--accent); color: #fff; }

/* Upload area */
.upload-area { margin-bottom: 16px; }
.upload-btn { position: relative; overflow: hidden; padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; background: var(--input-bg); color: var(--text); cursor: pointer; font-size: 0.85rem; transition: all 0.15s; }
.upload-btn:hover { border-color: var(--text-muted); background: var(--preview-bg); }
.upload-btn input[type="file"] { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

/* Form controls */
.form-group { margin-bottom: 16px; }
.form-group label { display: block; font-size: 0.85rem; font-weight: 500; margin-bottom: 4px; color: var(--text); }
.form-group input[type="text"],
.form-group textarea { width: 100%; max-width: 400px; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 0.9rem; font-family: inherit; background: var(--input-bg); color: var(--text); }
.form-group textarea { resize: vertical; min-height: 60px; }
.range-row { display: flex; align-items: center; gap: 12px; max-width: 400px; }
.range-row input[type="range"] { flex: 1; }
.range-value { font-size: 0.9rem; font-weight: 600; min-width: 24px; text-align: center; }

/* Checkbox */
.checkbox-row { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.85rem; font-weight: 500; }
.checkbox-row input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }

/* Generate button */
.generate-btn { padding: 10px 32px; background: var(--accent); color: #fff; border: none; border-radius: 6px; font-size: 0.95rem; font-weight: 500; cursor: pointer; transition: background 0.15s; }
.generate-btn:hover { background: var(--accent-hover); }
.generate-btn:disabled { background: #999; cursor: not-allowed; }

/* Status text */
.status-text { font-size: 0.85rem; color: var(--text-muted); margin-top: 12px; }
.status-text.error { color: #d32f2f; }

/* Output panel */
.output-area { flex: 1; display: flex; flex-direction: column; }
.output-preview { width: 100%; max-width: 400px; aspect-ratio: 1; background: var(--preview-bg); border: 2px solid var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-bottom: 12px; position: relative; }
.output-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }
.overlay-img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; pointer-events: none; opacity: 0; }

/* Overlay controls */
.overlay-controls { width: 100%; max-width: 400px; margin-bottom: 12px; display: none; }
.overlay-controls.active { display: block; }
.overlay-controls label { font-size: 0.85rem; font-weight: 500; margin-bottom: 4px; display: block; color: var(--text); }

/* Variations strip */
.variations-strip { width: 100%; max-width: 400px; margin-bottom: 12px; display: none; }
.variations-strip.active { display: block; }
.variations-strip .section-label { margin-bottom: 6px; }
.variations-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
.variations-header .section-label { margin-bottom: 0; }
.variations-spinner { font-size: 0.8rem; color: var(--text-muted); }
.variations-scroll { display: flex; gap: 6px; flex-wrap: wrap; }
.variations-thumb { width: 144px; height: 144px; border-radius: 4px; border: 2px solid var(--border);
  overflow: hidden; cursor: pointer; flex-shrink: 0; transition: border-color 0.15s; position: relative; }
.variations-thumb:hover { border-color: var(--accent); }
.variations-thumb.selected { border-color: var(--accent); border-width: 3px; }
.variations-thumb img { width: 100%; height: 100%; object-fit: cover; }
.variations-thumb.pending { display: flex; align-items: center; justify-content: center;
  background: var(--preview-bg); }
.variations-thumb.pending::after { content: ''; width: 16px; height: 16px; border: 2px solid var(--text-muted);
  border-top-color: var(--accent); border-radius: 50%; animation: varspin 0.8s linear infinite; }
@keyframes varspin { to { transform: rotate(360deg); } }

/* Progress bar */
.progress-bar-container { width: 100%; max-width: 400px; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; margin-bottom: 8px; display: none; }
.progress-bar-container.active { display: block; }
.progress-bar-fill { height: 100%; background: var(--accent); border-radius: 3px; transition: width 0.4s ease; width: 0%; }

/* History strip */
.history-strip { border-top: 1px solid var(--border); background: var(--panel-bg); padding: 12px 24px; }
.history-strip .section-label { margin-bottom: 8px; }
.history-scroll { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px; }
.history-thumb { width: 64px; height: 64px; border-radius: 4px; border: 2px solid var(--border); overflow: hidden; cursor: pointer; flex-shrink: 0; transition: border-color 0.15s; }
.history-thumb:hover { border-color: var(--accent); }
.history-thumb img { width: 100%; height: 100%; object-fit: cover; }
.history-empty { color: var(--text-muted); font-size: 0.85rem; }

/* Lightbox overlay */
.lightbox { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 100; cursor: pointer; }
.lightbox img { max-width: 90vw; max-height: 90vh; object-fit: contain; border-radius: 8px; }

/* Live Sketch canvas */
.canvas-wrapper { width: 100%; max-width: 400px; margin-bottom: 12px; position: relative; }
.canvas-wrapper canvas { width: 100%; aspect-ratio: 1; border: 2px solid var(--border); border-radius: 8px; cursor: crosshair; touch-action: none; display: block; background-image: repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%); background-size: 16px 16px; }
body.dark .canvas-wrapper canvas { background-image: repeating-conic-gradient(#444 0% 25%, #333 0% 50%); }
.canvas-overlay-img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; pointer-events: none; border-radius: 8px; opacity: 0.2; display: none; }
.canvas-toolbar { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; max-width: 400px; }
.tool-btn { padding: 6px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--input-bg); color: var(--text); cursor: pointer; font-size: 0.8rem; transition: all 0.15s; }
.tool-btn:hover { border-color: var(--text-muted); background: var(--preview-bg); }
.tool-btn.active { border-color: var(--accent); background: var(--accent); color: #fff; }
.canvas-toolbar .range-row { flex: 1; min-width: 120px; }
.queue-status { font-size: 0.8rem; color: var(--text-muted); margin-top: 4px; }

/* Context menu */
.ctx-menu { position: fixed; z-index: 200; background: var(--panel-bg); border: 1px solid var(--border);
  border-radius: 6px; padding: 4px 0; box-shadow: 0 4px 16px rgba(0,0,0,0.2); min-width: 180px; }
.ctx-menu-item { padding: 8px 16px; font-size: 0.85rem; cursor: pointer; color: var(--text); }
.ctx-menu-item:hover { background: var(--preview-bg); }

/* Confirm modal */
.confirm-modal { position: fixed; inset: 0; z-index: 300; background: rgba(0,0,0,0.5);
  display: flex; align-items: center; justify-content: center; }
.confirm-dialog { background: var(--panel-bg); border: 1px solid var(--border); border-radius: 8px;
  padding: 24px; max-width: 360px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
.confirm-dialog p { font-size: 0.95rem; margin-bottom: 8px; color: var(--text); }
.confirm-dialog .confirm-preview { width: 100%; aspect-ratio: 1; max-width: 200px; border-radius: 6px;
  border: 1px solid var(--border); object-fit: cover; margin: 12px auto; display: block; }
.confirm-dialog .confirm-buttons { display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px; }
.confirm-dialog .confirm-btn { padding: 8px 20px; border-radius: 6px; font-size: 0.85rem; font-weight: 500; cursor: pointer; border: 1px solid var(--border); }
.confirm-dialog .confirm-btn.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
.confirm-dialog .confirm-btn.primary:hover { background: var(--accent-hover); }
.confirm-dialog .confirm-btn.secondary { background: var(--input-bg); color: var(--text); }
.confirm-dialog .confirm-btn.secondary:hover { background: var(--preview-bg); }

/* Responsive */
@media (max-width: 768px) {
  main { flex-direction: column; }
  .panel-left { border-right: none; border-bottom: 1px solid var(--border); }
  .preview-container, .output-preview, .form-group input, .form-group textarea, .canvas-wrapper { max-width: 100%; }
}
</style>
</head>
<body>

<header>
  <h1>Pencil Flux Klein</h1>
  <div class="header-right">
    <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">&#9790;</button>
    <div class="health-indicator">
      <span class="status-dot disconnected" id="healthDot"></span>
      <span id="healthText">Checking...</span>
    </div>
  </div>
</header>

<main>
  <div class="panel panel-left">
    <div class="section-label">Input Sketch</div>

    <div class="mode-tabs">
      <button class="mode-tab active" data-mode="presets">Presets</button>
      <button class="mode-tab" data-mode="upload">Upload</button>
      <button class="mode-tab" data-mode="live">Live Sketch</button>
    </div>

    <!-- Presets mode -->
    <div class="mode-content active" id="modePresets">
      <div class="preview-container" id="sketchPreview">
        <span class="preview-placeholder">Select a sketch below</span>
      </div>
      <div class="sketch-presets" id="sketchPresets">
        <!-- Populated by JS -->
      </div>
    </div>

    <!-- Upload mode -->
    <div class="mode-content" id="modeUpload">
      <div class="preview-container" id="uploadPreview">
        <span class="preview-placeholder">Upload an image</span>
      </div>
      <div class="upload-area">
        <button class="upload-btn" id="uploadBtn">
          Choose file...
          <input type="file" id="fileInput" accept="image/*">
        </button>
      </div>
    </div>

    <!-- Live Sketch mode -->
    <div class="mode-content" id="modeLive">
      <div class="canvas-wrapper">
        <canvas id="sketchCanvas" width="512" height="512"></canvas>
        <img class="canvas-overlay-img" id="canvasOverlayImg" alt="">
      </div>
      <div class="canvas-toolbar">
        <button class="tool-btn active" id="pencilBtn" data-tool="pencil">Pencil</button>
        <button class="tool-btn" id="eraserBtn" data-tool="eraser">Eraser</button>
        <div class="range-row">
          <input type="range" id="strokeWidthInput" min="1" max="30" value="3">
          <span class="range-value" id="strokeWidthValue">3</span>
        </div>
        <button class="tool-btn" id="clearCanvasBtn">Clear</button>
      </div>
      <div class="form-group" id="canvasOverlayControls" style="display:none">
        <label>Result overlay</label>
        <div class="range-row">
          <input type="range" id="canvasOverlayOpacity" min="0" max="100" value="20">
          <span class="range-value" id="canvasOverlayOpacityValue">20%</span>
        </div>
      </div>
      <div class="queue-status" id="queueStatus"></div>
    </div>

    <!-- Prompt (always visible) -->
    <div class="form-group">
      <label for="promptInput">Prompt</label>
      <textarea id="promptInput" placeholder="Describe the image you want..."></textarea>
    </div>

    <!-- Creativity slider (always visible) -->
    <div class="form-group">
      <label>Creativity (low = faithful to sketch, high = more creative)</label>
      <div class="range-row">
        <input type="range" id="denoiseInput" min="0" max="100" value="75" step="5">
        <span class="range-value" id="denoiseValue">0.75</span>
      </div>
    </div>

    <!-- Shared controls (hidden in live mode) -->
    <div id="sharedControls">
      <div class="form-group">
        <label>Steps</label>
        <div class="range-row">
          <input type="range" id="stepsInput" min="1" max="50" value="4">
          <span class="range-value" id="stepsValue">4</span>
        </div>
      </div>

      <div class="form-group" id="hdGroup">
        <label class="checkbox-row">
          <input type="checkbox" id="hdToggle">
          <span>HD mode <small style="color:var(--text-muted)">(two-pass: 512 then upscale to 1024)</small></span>
        </label>
      </div>

      <button class="generate-btn" id="generateBtn" disabled>Generate</button>
      <div class="status-text" id="statusText"></div>
    </div>
  </div>

  <div class="panel panel-right">
    <div class="section-label">Output</div>
    <div class="mode-tabs" aria-hidden="true" style="visibility:hidden;pointer-events:none">
      <button class="mode-tab">&nbsp;</button>
    </div>
    <div class="output-area">
      <div class="output-preview" id="outputPreview">
        <span class="preview-placeholder">Result will appear here</span>
      </div>
      <div class="overlay-controls" id="overlayControls">
        <label>Sketch overlay</label>
        <div class="range-row">
          <input type="range" id="overlayOpacity" min="0" max="100" value="0">
          <span class="range-value" id="overlayOpacityValue">0%</span>
        </div>
      </div>
      <div class="variations-strip" id="variationsStrip">
        <div class="variations-header">
          <div class="section-label">Variations</div>
          <span class="variations-spinner" id="variationsSpinner"></span>
        </div>
        <div class="variations-scroll" id="variationsScroll"></div>
      </div>
      <div class="progress-bar-container" id="progressBar">
        <div class="progress-bar-fill" id="progressFill"></div>
      </div>
      <div class="status-text" id="outputStatus"></div>
    </div>
  </div>
</main>

<div class="history-strip">
  <div class="section-label">History</div>
  <div class="history-scroll" id="historyScroll">
    <span class="history-empty" id="historyEmpty">No generations yet</span>
  </div>
</div>

<script>
const $ = (sel) => document.querySelector(sel);
const API = '';

// ========================================================================
// State
// ========================================================================
let selectedSketch = null;   // preset id string
let uploadedBase64 = null;   // base64 string for uploaded image
let polling = null;
let currentMode = 'presets'; // 'presets' | 'upload' | 'live'

// Variety batch state
let varietyJobs = [];       // Array of { jobId, status, pollTimer, thumbEl }
const VARIETY_COUNT = 8;
const VARIETY_IDLE_EXTRA = 8;   // Additional variations after idle
const VARIETY_IDLE_MS = 10000;  // 10 seconds idle before extra batch
let varietyIdleTimer = null;
let varietyCapturedInputs = null; // { base64, prompt, steps, denoise } saved from first batch

// ========================================================================
// Queue Manager (synced copy of src/queue-manager.ts logic)
// ========================================================================
const MAX_QUEUE = 3;

function createQueue() {
  return { submissions: [], sequenceNumber: 0 };
}

function queueAddSubmission(queue, jobId) {
  queue.sequenceNumber++;
  const entry = { jobId, seqNum: queue.sequenceNumber, status: 'polling', pollTimer: null };
  let evicted = null;
  if (queue.submissions.length >= MAX_QUEUE) {
    queue.submissions.sort((a, b) => a.seqNum - b.seqNum);
    evicted = queue.submissions.shift();
  }
  queue.submissions.push(entry);
  return { entry, evicted };
}

function queueShouldDisplay(queue, entry) {
  if (entry.status !== 'completed') return false;
  return !queue.submissions.some(e => e.seqNum > entry.seqNum && e.status === 'completed');
}

function queueFindEntry(queue, jobId) {
  return queue.submissions.find(e => e.jobId === jobId);
}

function queueActiveCount(queue) {
  return queue.submissions.filter(e => e.status === 'pending' || e.status === 'polling').length;
}

const liveQueue = createQueue();

// ========================================================================
// Canvas Tools (synced copy of src/canvas-tools.ts logic)
// ========================================================================
let toolState = { tool: 'pencil', strokeWidth: 3 };

function getStrokeStyle() {
  return toolState.tool === 'eraser' ? 'destination-out' : 'source-over';
}

function toCanvasCoords(cssX, cssY, cssWidth, cssHeight, canvasWidth, canvasHeight) {
  return { x: (cssX / cssWidth) * canvasWidth, y: (cssY / cssHeight) * canvasHeight };
}

// ========================================================================
// Health check
// ========================================================================
async function checkHealth() {
  try {
    const res = await fetch(`${API}/api/health`);
    const data = await res.json();
    const dot = $('#healthDot');
    const text = $('#healthText');
    if (data.comfyui_reachable) {
      dot.className = 'status-dot connected';
      text.textContent = 'Connected';
    } else {
      dot.className = 'status-dot disconnected';
      text.textContent = 'Disconnected';
    }
  } catch {
    $('#healthDot').className = 'status-dot disconnected';
    $('#healthText').textContent = 'Backend offline';
  }
}

// ========================================================================
// Mode tabs
// ========================================================================
document.querySelectorAll('.mode-tab').forEach(tab => {
  tab.addEventListener('click', () => switchMode(tab.dataset.mode));
});

function switchMode(mode) {
  currentMode = mode;
  // Update tab highlight
  document.querySelectorAll('.mode-tab').forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
  // Show/hide mode content
  document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
  if (mode === 'presets') $('#modePresets').classList.add('active');
  else if (mode === 'upload') $('#modeUpload').classList.add('active');
  else if (mode === 'live') $('#modeLive').classList.add('active');

  // In live mode: hide shared controls (generate btn, HD toggle, etc.)
  const shared = $('#sharedControls');
  if (mode === 'live') {
    shared.style.display = 'none';
  } else {
    shared.style.display = '';
    abortVarietyBatch();
  }

  // Show overlay controls only in live mode
  const overlayCtrl = $('#overlayControls');
  if (mode === 'live') {
    overlayCtrl.classList.add('active');
  } else {
    overlayCtrl.classList.remove('active');
    // Hide canvas overlay when leaving live mode
    if (typeof canvasOverlayImg !== 'undefined') {
      canvasOverlayImg.style.display = 'none';
      $('#canvasOverlayControls').style.display = 'none';
    }
  }
}

// ========================================================================
// Load sketch presets
// ========================================================================
async function loadSketches() {
  try {
    const res = await fetch(`${API}/api/sketches`);
    const sketches = await res.json();
    const container = $('#sketchPresets');
    container.innerHTML = '';

    for (const s of sketches) {
      const btn = document.createElement('button');
      btn.textContent = s.name;
      btn.dataset.id = s.id;
      btn.dataset.prompt = s.default_prompt;
      btn.addEventListener('click', () => selectPreset(s.id, s.default_prompt));
      container.appendChild(btn);
    }
  } catch (e) {
    console.error('Failed to load sketches:', e);
  }
}

async function selectPreset(id, defaultPrompt) {
  selectedSketch = id;
  uploadedBase64 = null;

  // Highlight active button
  document.querySelectorAll('.sketch-presets button').forEach(b => {
    b.classList.toggle('active', b.dataset.id === id);
  });

  // Load preview image
  try {
    const res = await fetch(`${API}/api/sketches/${id}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    showSketchPreview(url);
  } catch (e) {
    console.error('Failed to load sketch:', e);
  }

  // Fill prompt
  $('#promptInput').value = defaultPrompt;
  $('#generateBtn').disabled = false;
}

// ========================================================================
// Upload handling
// ========================================================================
$('#fileInput').addEventListener('change', handleUpload);

function handleUpload(e) {
  const file = e.target.files[0];
  if (!file) return;

  selectedSketch = null;
  document.querySelectorAll('.sketch-presets button').forEach(b => b.classList.remove('active'));

  const reader = new FileReader();
  reader.onload = () => {
    const dataUrl = reader.result;
    uploadedBase64 = dataUrl.split(',')[1];
    // Show in upload preview
    const container = $('#uploadPreview');
    container.innerHTML = '';
    container.classList.add('has-image');
    const img = document.createElement('img');
    img.src = dataUrl;
    container.appendChild(img);
    $('#generateBtn').disabled = false;
  };
  reader.readAsDataURL(file);
}

function showSketchPreview(src) {
  const container = $('#sketchPreview');
  container.innerHTML = '';
  container.classList.add('has-image');
  const img = document.createElement('img');
  img.src = src;
  container.appendChild(img);
}

// ========================================================================
// Sliders
// ========================================================================
$('#stepsInput').addEventListener('input', (e) => {
  $('#stepsValue').textContent = e.target.value;
});
$('#denoiseInput').addEventListener('input', (e) => {
  $('#denoiseValue').textContent = (e.target.value / 100).toFixed(2);
  scheduleSubmit();
});
$('#strokeWidthInput').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  toolState.strokeWidth = Math.max(1, Math.min(30, val));
  $('#strokeWidthValue').textContent = toolState.strokeWidth;
});

// ========================================================================
// Progress bar
// ========================================================================
const STATUS_PROGRESS = {
  queued: 10, uploading: 25, submitted: 40, processing: 60, downloading: 85, completed: 100,
};

function setProgress(status) {
  const container = $('#progressBar');
  const fill = $('#progressFill');
  const pct = STATUS_PROGRESS[status];
  if (pct !== undefined) {
    container.classList.add('active');
    fill.style.width = pct + '%';
  }
  if (status === 'completed' || status === 'failed' || status === 'cancelled') {
    // Hide after a short delay so the 100% state is visible
    setTimeout(() => {
      container.classList.remove('active');
      fill.style.width = '0%';
    }, status === 'completed' ? 600 : 0);
  }
}

// ========================================================================
// Generate (presets/upload modes)
// ========================================================================
$('#generateBtn').addEventListener('click', startGeneration);

async function startGeneration() {
  const sketch = uploadedBase64 || selectedSketch;
  if (!sketch) return;

  const prompt = $('#promptInput').value.trim() || undefined;
  const steps = parseInt($('#stepsInput').value);
  const denoise = parseInt($('#denoiseInput').value) / 100;
  const hd = $('#hdToggle').checked;

  const btn = $('#generateBtn');
  btn.disabled = true;
  btn.textContent = 'Generating...';
  $('#statusText').textContent = '';
  $('#statusText').className = 'status-text';
  $('#outputStatus').textContent = '';
  $('#outputStatus').className = 'status-text';

  // Clear output and show progress
  setOutputPlaceholder('Generating...');
  setProgress('queued');

  try {
    const res = await fetch(`${API}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sketch, prompt, steps, denoise, hd }),
    });

    if (!res.ok) {
      const err = await res.json();
      throw new Error(err.detail || 'Generation failed');
    }

    const data = await res.json();
    pollJob(data.job_id);
  } catch (e) {
    btn.disabled = false;
    btn.textContent = 'Generate';
    $('#statusText').textContent = `Error: ${e.message}`;
    $('#statusText').className = 'status-text error';
  }
}

function pollJob(jobId) {
  if (polling) clearInterval(polling);

  polling = setInterval(async () => {
    try {
      const res = await fetch(`${API}/api/status/${jobId}`);
      const data = await res.json();
      const elapsed = data.elapsed_seconds ? `${data.elapsed_seconds}s` : '';
      $('#outputStatus').textContent = `Status: ${data.status}${elapsed ? ` (${elapsed})` : ''}`;
      setProgress(data.status);

      if (data.status === 'completed') {
        clearInterval(polling);
        polling = null;
        showResult(jobId, elapsed);
        $('#generateBtn').disabled = false;
        $('#generateBtn').textContent = 'Generate';
      } else if (data.status === 'failed') {
        clearInterval(polling);
        polling = null;
        $('#outputStatus').textContent = `Failed: ${data.error || 'Unknown error'} (${elapsed})`;
        $('#outputStatus').className = 'status-text error';
        setOutputPlaceholder('Generation failed');
        $('#generateBtn').disabled = false;
        $('#generateBtn').textContent = 'Generate';
      }
    } catch (e) {
      clearInterval(polling);
      polling = null;
      $('#outputStatus').textContent = 'Error polling status';
      $('#outputStatus').className = 'status-text error';
      $('#generateBtn').disabled = false;
      $('#generateBtn').textContent = 'Generate';
    }
  }, 1000);
}

async function showResult(jobId, elapsed) {
  try {
    const res = await fetch(`${API}/api/result/${jobId}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    setOutputImage(url);

    $('#outputStatus').textContent = `Completed (${elapsed})`;

    // Add to history
    addToHistory(url);
  } catch (e) {
    $('#outputStatus').textContent = 'Error loading result';
    $('#outputStatus').className = 'status-text error';
  }
}

function addToHistory(imageUrl) {
  const empty = $('#historyEmpty');
  if (empty) empty.remove();

  const scroll = $('#historyScroll');
  const thumb = document.createElement('div');
  thumb.className = 'history-thumb';
  const img = document.createElement('img');
  img.src = imageUrl;
  thumb.appendChild(img);
  thumb.addEventListener('click', () => openLightbox(imageUrl));
  thumb.addEventListener('contextmenu', (e) => showImageContextMenu(e, imageUrl));
  scroll.prepend(thumb);
}

// ========================================================================
// Context menu + confirm modal for "Use as input sketch"
// ========================================================================
let activeCtxMenu = null;

function showImageContextMenu(e, imageUrl) {
  e.preventDefault();
  dismissCtxMenu();

  const menu = document.createElement('div');
  menu.className = 'ctx-menu';

  const item = document.createElement('div');
  item.className = 'ctx-menu-item';
  item.textContent = 'Use as input sketch';
  item.addEventListener('click', () => {
    dismissCtxMenu();
    confirmUseAsSketch(imageUrl);
  });
  menu.appendChild(item);

  // "Cancel all generations" option â€” show when there are active jobs
  const hasActiveJobs = varietyJobs.some(j => j.status === 'pending' || j.status === 'polling')
    || varietyIdleTimer
    || queueActiveCount(liveQueue) > 0;
  if (hasActiveJobs) {
    const cancelItem = document.createElement('div');
    cancelItem.className = 'ctx-menu-item';
    cancelItem.style.color = '#d32f2f';
    cancelItem.textContent = 'Cancel all generations';
    cancelItem.addEventListener('click', () => {
      dismissCtxMenu();
      abortVarietyBatch();
      // Also cancel live queue jobs
      for (const entry of liveQueue.submissions) {
        if (entry.pollTimer) clearInterval(entry.pollTimer);
        if (entry.status === 'pending' || entry.status === 'polling') {
          fetch(`${API}/api/cancel/${entry.jobId}`, { method: 'POST' }).catch(() => {});
        }
      }
      liveQueue.submissions = [];
      updateQueueStatus();
      setProgress('cancelled');
    });
    menu.appendChild(cancelItem);
  }

  // Position at cursor, clamp to viewport
  menu.style.left = Math.min(e.clientX, window.innerWidth - 200) + 'px';
  menu.style.top = Math.min(e.clientY, window.innerHeight - 50) + 'px';
  document.body.appendChild(menu);
  activeCtxMenu = menu;

  // Dismiss on click elsewhere or Escape
  setTimeout(() => {
    document.addEventListener('click', dismissCtxMenu, { once: true });
    document.addEventListener('contextmenu', dismissCtxMenu, { once: true });
  }, 0);
}

function dismissCtxMenu() {
  if (activeCtxMenu) {
    activeCtxMenu.remove();
    activeCtxMenu = null;
  }
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') dismissCtxMenu();
});

function confirmUseAsSketch(imageUrl) {
  const overlay = document.createElement('div');
  overlay.className = 'confirm-modal';

  const dialog = document.createElement('div');
  dialog.className = 'confirm-dialog';
  dialog.innerHTML = `
    <p><strong>Use as input sketch?</strong></p>
    <p style="font-size:0.8rem;color:var(--text-muted)">This will replace the current canvas and switch to Live Sketch mode.</p>
    <img class="confirm-preview" src="${imageUrl}" alt="Preview">
    <div class="confirm-buttons">
      <button class="confirm-btn secondary" data-action="cancel">Cancel</button>
      <button class="confirm-btn primary" data-action="confirm">Use as sketch</button>
    </div>
  `;
  overlay.appendChild(dialog);
  document.body.appendChild(overlay);

  // Close on backdrop click
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });

  dialog.querySelector('[data-action="cancel"]').addEventListener('click', () => overlay.remove());
  dialog.querySelector('[data-action="confirm"]').addEventListener('click', () => {
    overlay.remove();
    applyAsSketchInput(imageUrl);
  });

  // Escape to close
  const onKey = (e) => { if (e.key === 'Escape') { overlay.remove(); document.removeEventListener('keydown', onKey); } };
  document.addEventListener('keydown', onKey);
}

function applyAsSketchInput(imageUrl) {
  const img = new Image();
  img.onload = () => {
    ctx.clearRect(0, 0, 512, 512);
    ctx.drawImage(img, 0, 0, 512, 512);
    hasStrokes = true;
    switchMode('live');
    updateOverlayImage();
    scheduleSubmit();
  };
  img.src = imageUrl;
}

function openLightbox(src) {
  const overlay = document.createElement('div');
  overlay.className = 'lightbox';
  const img = document.createElement('img');
  img.src = src;
  overlay.appendChild(img);
  overlay.addEventListener('click', () => overlay.remove());
  document.body.appendChild(overlay);
}

// ========================================================================
// Canvas drawing engine
// ========================================================================
const canvas = $('#sketchCanvas');
const ctx = canvas.getContext('2d');
let isDrawing = false;
let debounceTimer = null;
let hasStrokes = false;

// Init canvas to transparent (checkerboard shows through)
ctx.clearRect(0, 0, 512, 512);

// Tool buttons
$('#pencilBtn').addEventListener('click', () => {
  toolState.tool = 'pencil';
  $('#pencilBtn').classList.add('active');
  $('#eraserBtn').classList.remove('active');
});
$('#eraserBtn').addEventListener('click', () => {
  toolState.tool = 'eraser';
  $('#eraserBtn').classList.add('active');
  $('#pencilBtn').classList.remove('active');
});
$('#clearCanvasBtn').addEventListener('click', () => {
  ctx.clearRect(0, 0, 512, 512);
  hasStrokes = false;
  updateQueueStatus();
  updateOverlayImage();
  canvasOverlayImg.style.display = 'none';
  $('#canvasOverlayControls').style.display = 'none';
  abortVarietyBatch();
});

function getCanvasPoint(e) {
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;
  if (e.touches) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  return toCanvasCoords(
    clientX - rect.left, clientY - rect.top,
    rect.width, rect.height,
    512, 512
  );
}

function startStroke(e) {
  e.preventDefault();
  isDrawing = true;
  const pt = getCanvasPoint(e);
  ctx.globalCompositeOperation = getStrokeStyle();
  ctx.beginPath();
  ctx.moveTo(pt.x, pt.y);
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = toolState.strokeWidth;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
}

function continueStroke(e) {
  if (!isDrawing) return;
  e.preventDefault();
  const pt = getCanvasPoint(e);
  ctx.lineTo(pt.x, pt.y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(pt.x, pt.y);
}

function endStroke(e) {
  if (!isDrawing) return;
  e.preventDefault();
  isDrawing = false;
  ctx.globalCompositeOperation = 'source-over';
  hasStrokes = true;
  updateOverlayImage();
  // Debounce submission
  scheduleSubmit();
}

// Mouse events
canvas.addEventListener('mousedown', startStroke);
canvas.addEventListener('mousemove', continueStroke);
canvas.addEventListener('mouseup', endStroke);
canvas.addEventListener('mouseleave', endStroke);

// Touch events
canvas.addEventListener('touchstart', startStroke, { passive: false });
canvas.addEventListener('touchmove', continueStroke, { passive: false });
canvas.addEventListener('touchend', endStroke, { passive: false });
canvas.addEventListener('touchcancel', endStroke, { passive: false });

// ========================================================================
// Live queue submission
// ========================================================================
function canvasToWhiteBgDataURL() {
  // Composite canvas onto white background for export (transparent = white, not black)
  const tmp = document.createElement('canvas');
  tmp.width = canvas.width;
  tmp.height = canvas.height;
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#ffffff';
  tctx.fillRect(0, 0, tmp.width, tmp.height);
  tctx.drawImage(canvas, 0, 0);
  return tmp.toDataURL('image/png');
}

async function submitCanvasToQueue() {
  // Get canvas as base64 (with white background)
  const dataUrl = canvasToWhiteBgDataURL();
  const base64 = dataUrl.split(',')[1];

  const prompt = $('#promptInput')?.value?.trim() || undefined;
  const steps = parseInt($('#stepsInput').value);
  const denoise = parseInt($('#denoiseInput').value) / 100;

  try {
    const res = await fetch(`${API}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sketch: base64, prompt, steps, denoise, hd: false }),
    });

    if (!res.ok) {
      console.error('Live submit failed:', res.status);
      return;
    }

    const data = await res.json();
    const { entry, evicted } = queueAddSubmission(liveQueue, data.job_id);

    // Cancel evicted job (fire-and-forget)
    if (evicted) {
      if (evicted.pollTimer) clearInterval(evicted.pollTimer);
      fetch(`${API}/api/cancel/${evicted.jobId}`, { method: 'POST' }).catch(() => {});
    }

    // Start polling this job
    entry.pollTimer = setInterval(() => pollLiveJob(entry), 1000);
    updateQueueStatus();
  } catch (e) {
    console.error('Live submit error:', e);
  }
}

async function pollLiveJob(entry) {
  try {
    const res = await fetch(`${API}/api/status/${entry.jobId}`);
    const data = await res.json();

    setProgress(data.status);

    if (data.status === 'completed') {
      entry.status = 'completed';
      if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }

      if (queueShouldDisplay(liveQueue, entry)) {
        await showLiveResult(entry.jobId);
      }
      updateQueueStatus();
    } else if (data.status === 'failed' || data.status === 'cancelled') {
      entry.status = data.status;
      if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }
      updateQueueStatus();
    }
  } catch (e) {
    entry.status = 'failed';
    if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }
    updateQueueStatus();
  }
}

async function showLiveResult(jobId) {
  try {
    const res = await fetch(`${API}/api/result/${jobId}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    setOutputImage(url);
    updateCanvasOverlay(url);

    $('#outputStatus').textContent = 'Live result';
    $('#outputStatus').className = 'status-text';

    addToHistory(url);

    // Fire variety batch after first live result
    if (currentMode === 'live') startVarietyBatch();
  } catch (e) {
    console.error('Error loading live result:', e);
  }
}

function updateQueueStatus() {
  const count = queueActiveCount(liveQueue);
  const el = $('#queueStatus');
  if (count > 0) {
    el.textContent = `${count} generation${count > 1 ? 's' : ''} in queue`;
  } else if (hasStrokes) {
    el.textContent = 'Draw to generate';
  } else {
    el.textContent = '';
  }
}

// ========================================================================
// Variety batch manager
// ========================================================================
function startVarietyBatch() {
  abortVarietyBatch();

  // Capture current inputs for this batch (and potential idle extension)
  const dataUrl = canvasToWhiteBgDataURL();
  varietyCapturedInputs = {
    base64: dataUrl.split(',')[1],
    prompt: $('#promptInput')?.value?.trim() || undefined,
    steps: parseInt($('#stepsInput').value),
    denoise: parseInt($('#denoiseInput').value) / 100,
  };

  // Show strip and clear contents
  $('#variationsStrip').classList.add('active');
  $('#variationsScroll').innerHTML = '';

  fireVarietyJobs(VARIETY_COUNT);
}

function fireVarietyJobs(count) {
  const { base64, prompt, steps, denoise } = varietyCapturedInputs;
  const scroll = $('#variationsScroll');
  const startIdx = varietyJobs.length;

  for (let i = 0; i < count; i++) {
    const thumbEl = document.createElement('div');
    thumbEl.className = 'variations-thumb pending';
    scroll.appendChild(thumbEl);

    const job = { jobId: null, status: 'pending', pollTimer: null, thumbEl };
    varietyJobs.push(job);

    // Fire request (IIFE to capture index)
    (async (idx) => {
      try {
        const res = await fetch(`${API}/api/generate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sketch: base64, prompt, steps, denoise, hd: false }),
        });
        if (!res.ok) {
          varietyJobs[idx].status = 'failed';
          varietyJobs[idx].thumbEl.remove();
          updateVarietySpinner();
          return;
        }
        const data = await res.json();
        varietyJobs[idx].jobId = data.job_id;
        varietyJobs[idx].status = 'polling';
        varietyJobs[idx].pollTimer = setInterval(() => pollVarietyJob(idx), 1000);
      } catch (e) {
        varietyJobs[idx].status = 'failed';
        varietyJobs[idx].thumbEl.remove();
        updateVarietySpinner();
      }
    })(startIdx + i);
  }

  updateVarietySpinner();
}

function updateVarietySpinner() {
  const spinner = $('#variationsSpinner');
  const total = varietyJobs.length;
  const completed = varietyJobs.filter(j => j.status === 'completed').length;
  const done = varietyJobs.filter(j => j.status === 'completed' || j.status === 'failed').length;

  if (done >= total) {
    spinner.textContent = '';
    // If first batch just finished and we haven't extended yet, start idle timer
    if (total === VARIETY_COUNT && varietyCapturedInputs) {
      if (varietyIdleTimer) clearTimeout(varietyIdleTimer);
      varietyIdleTimer = setTimeout(() => {
        varietyIdleTimer = null;
        if (varietyJobs.length === VARIETY_COUNT && varietyCapturedInputs) {
          fireVarietyJobs(VARIETY_IDLE_EXTRA);
        }
      }, VARIETY_IDLE_MS);
    }
  } else {
    spinner.textContent = `Generating... ${completed}/${total}`;
  }
}

async function pollVarietyJob(idx) {
  const job = varietyJobs[idx];
  if (!job || !job.jobId) return;

  try {
    const res = await fetch(`${API}/api/status/${job.jobId}`);
    const data = await res.json();

    if (data.status === 'completed') {
      job.status = 'completed';
      if (job.pollTimer) { clearInterval(job.pollTimer); job.pollTimer = null; }

      // Fetch result image
      const imgRes = await fetch(`${API}/api/result/${job.jobId}`);
      const blob = await imgRes.blob();
      const url = URL.createObjectURL(blob);

      // Replace placeholder with image
      job.thumbEl.classList.remove('pending');
      job.thumbEl.innerHTML = '';
      const img = document.createElement('img');
      img.src = url;
      job.thumbEl.appendChild(img);

      // Click handler: show in main output
      job.thumbEl.addEventListener('click', () => {
        setOutputImage(url);
        updateCanvasOverlay(url);
        // Mark selected
        document.querySelectorAll('.variations-thumb').forEach(t => t.classList.remove('selected'));
        job.thumbEl.classList.add('selected');
      });
      job.thumbEl.addEventListener('contextmenu', (e) => showImageContextMenu(e, url));

      addToHistory(url);
      updateVarietySpinner();

    } else if (data.status === 'failed' || data.status === 'cancelled') {
      job.status = 'failed';
      if (job.pollTimer) { clearInterval(job.pollTimer); job.pollTimer = null; }
      job.thumbEl.remove();
      updateVarietySpinner();
    }
  } catch (e) {
    job.status = 'failed';
    if (job.pollTimer) { clearInterval(job.pollTimer); job.pollTimer = null; }
    job.thumbEl.remove();
    if (startVarietyBatch._updateSpinner) startVarietyBatch._updateSpinner();
  }
}

function abortVarietyBatch() {
  if (varietyIdleTimer) { clearTimeout(varietyIdleTimer); varietyIdleTimer = null; }
  for (const job of varietyJobs) {
    if (job.pollTimer) clearInterval(job.pollTimer);
    if (job.jobId && (job.status === 'pending' || job.status === 'polling')) {
      fetch(`${API}/api/cancel/${job.jobId}`, { method: 'POST' }).catch(() => {});
    }
  }
  varietyJobs = [];
  varietyCapturedInputs = null;
  $('#variationsStrip').classList.remove('active');
  $('#variationsScroll').innerHTML = '';
  $('#variationsSpinner').textContent = '';
}

// ========================================================================
// Dark mode toggle
// ========================================================================
(function initTheme() {
  const saved = localStorage.getItem('theme');
  if (saved === 'dark') document.body.classList.add('dark');
  updateThemeIcon();
})();

$('#themeToggle').addEventListener('click', () => {
  document.body.classList.toggle('dark');
  localStorage.setItem('theme', document.body.classList.contains('dark') ? 'dark' : 'light');
  updateThemeIcon();
});

function updateThemeIcon() {
  $('#themeToggle').innerHTML = document.body.classList.contains('dark') ? '&#9788;' : '&#9790;';
}

// ========================================================================
// Output overlay
// ========================================================================
const overlayImg = document.createElement('img');
overlayImg.className = 'overlay-img';
$('#outputPreview').appendChild(overlayImg);

$('#outputPreview').addEventListener('contextmenu', (e) => {
  const img = $('#outputPreview').querySelector('img:not(.overlay-img)');
  if (img && img.src) {
    showImageContextMenu(e, img.src);
  }
});

$('#overlayOpacity').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  overlayImg.style.opacity = val / 100;
  $('#overlayOpacityValue').textContent = val + '%';
});

function updateOverlayImage() {
  overlayImg.src = canvas.toDataURL('image/png');
}

function setOutputImage(url) {
  const container = $('#outputPreview');
  // Remove all children except overlay img
  Array.from(container.children).forEach(child => {
    if (child !== overlayImg) container.removeChild(child);
  });
  const img = document.createElement('img');
  img.src = url;
  container.insertBefore(img, overlayImg);
}

function setOutputPlaceholder(text) {
  const container = $('#outputPreview');
  Array.from(container.children).forEach(child => {
    if (child !== overlayImg) container.removeChild(child);
  });
  const span = document.createElement('span');
  span.className = 'preview-placeholder';
  span.textContent = text;
  container.insertBefore(span, overlayImg);
}

// ========================================================================
// Canvas overlay (output over input)
// ========================================================================
const canvasOverlayImg = $('#canvasOverlayImg');

$('#canvasOverlayOpacity').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  canvasOverlayImg.style.opacity = val / 100;
  $('#canvasOverlayOpacityValue').textContent = val + '%';
});

function updateCanvasOverlay(url) {
  canvasOverlayImg.src = url;
  canvasOverlayImg.style.display = 'block';
  $('#canvasOverlayControls').style.display = '';
}

// ========================================================================
// Debounced live submit
// ========================================================================
function scheduleSubmit() {
  if (debounceTimer) clearTimeout(debounceTimer);
  abortVarietyBatch();
  debounceTimer = setTimeout(() => {
    if (currentMode === 'live' && hasStrokes) {
      submitCanvasToQueue();
    }
  }, 300);
}

// ========================================================================
// Random prompt words
// ========================================================================
let wordList = [];

async function loadWordList() {
  try {
    const res = await fetch(`${API}/static/words.txt`);
    const text = await res.text();
    wordList = text.split('\n').filter(w => w.trim());
  } catch (e) {
    console.error('Failed to load word list:', e);
  }
}

function randomPrompt(count = 3) {
  if (!wordList.length) return '';
  const words = [];
  for (let i = 0; i < count; i++) {
    words.push(wordList[Math.floor(Math.random() * wordList.length)]);
  }
  return words.join(' ');
}

function initPrompt() {
  const prompt = $('#promptInput');
  if (!prompt.value.trim()) {
    prompt.value = randomPrompt(3);
  }
}

// ========================================================================
// Init
// ========================================================================
checkHealth();
setInterval(checkHealth, 30000);
loadSketches();
loadWordList().then(initPrompt);
// Default to live sketch mode
switchMode('live');
</script>
</body>
</html>
