<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pencil Flux Klein</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/* Theme variables */
:root {
  --bg: #f5f5f5;
  --panel-bg: #fff;
  --panel-alt: #fafafa;
  --text: #333;
  --text-muted: #888;
  --border: #ddd;
  --input-bg: #fff;
  --preview-bg: #eee;
  --accent: #1a1a2e;
  --accent-hover: #16213e;
}
body.dark {
  --bg: #1a1a1a;
  --panel-bg: #2a2a2e;
  --panel-alt: #232327;
  --text: #e0e0e0;
  --text-muted: #999;
  --border: #444;
  --input-bg: #333;
  --preview-bg: #333;
  --accent: #6c7bff;
  --accent-hover: #8b97ff;
}

body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; display: flex; flex-direction: column; }

/* Header */
header { background: var(--accent); color: #fff; padding: 12px 24px; display: flex; justify-content: space-between; align-items: center; }
header h1 { font-size: 1.25rem; font-weight: 600; }
.header-right { display: flex; align-items: center; gap: 16px; }
.theme-toggle { background: none; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: #fff; cursor: pointer; font-size: 1.1rem; padding: 4px 8px; line-height: 1; transition: border-color 0.15s; }
.theme-toggle:hover { border-color: rgba(255,255,255,0.6); }
.status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
.status-dot.connected { background: #4caf50; }
.status-dot.disconnected { background: #f44336; }
.health-indicator { display: flex; align-items: center; font-size: 0.85rem; opacity: 0.9; }
.gpu-stats { display: flex; align-items: center; gap: 8px; font-size: 0.75rem; opacity: 0.85; }
.gpu-stats .gpu-label { color: rgba(255,255,255,0.6); }
.gpu-stats .gpu-bar { width: 60px; height: 8px; background: rgba(255,255,255,0.2); border-radius: 4px; overflow: hidden; }
.gpu-stats .gpu-bar-fill { height: 100%; border-radius: 4px; transition: width 0.5s, background 0.5s; }
.gpu-stats .gpu-text { min-width: 32px; color: #fff; }

/* Main layout */
main { display: flex; flex: 1; gap: 0; overflow: hidden; align-items: flex-start; }
.panel { padding: 24px; overflow-y: auto; max-height: 100%; }
.panel-left { flex: 1; border-right: 1px solid var(--border); background: var(--panel-bg); min-width: 0; }
.panel-right { flex: 1; background: var(--panel-alt); min-width: 0; display: flex; flex-direction: column; }

/* Section labels */
.section-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 8px; font-weight: 600; }

/* Mode tabs */
.mode-tabs { display: flex; gap: 0; margin-bottom: 16px; border-bottom: 2px solid var(--border); }
.mode-tab { padding: 8px 16px; border: none; background: none; cursor: pointer; font-size: 0.85rem; font-weight: 500; color: var(--text-muted); border-bottom: 2px solid transparent; margin-bottom: -2px; transition: all 0.15s; }
.mode-tab:hover { color: var(--text); }
.mode-tab.active { color: var(--accent); border-bottom-color: var(--accent); font-weight: 600; }
.mode-content { display: none; }
.mode-content.active { display: block; }

/* Image preview areas */
.preview-container { width: 100%; max-width: 400px; aspect-ratio: 1; background: var(--preview-bg); border: 2px dashed var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-bottom: 16px; position: relative; }
.preview-container img { max-width: 100%; max-height: 100%; object-fit: contain; }
.preview-container.has-image { border-style: solid; border-color: var(--border); }
.preview-placeholder { color: var(--text-muted); font-size: 0.9rem; }

/* Sketch preset buttons */
.sketch-presets { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
.sketch-presets button { padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; background: var(--input-bg); color: var(--text); cursor: pointer; font-size: 0.85rem; transition: all 0.15s; }
.sketch-presets button:hover { border-color: var(--text-muted); background: var(--preview-bg); }
.sketch-presets button.active { border-color: var(--accent); background: var(--accent); color: #fff; }

/* Upload area */
.upload-area { margin-bottom: 16px; }
.upload-btn { position: relative; overflow: hidden; padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; background: var(--input-bg); color: var(--text); cursor: pointer; font-size: 0.85rem; transition: all 0.15s; }
.upload-btn:hover { border-color: var(--text-muted); background: var(--preview-bg); }
.upload-btn input[type="file"] { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

/* Form controls */
.form-group { margin-bottom: 16px; }
.form-group label { display: block; font-size: 0.85rem; font-weight: 500; margin-bottom: 4px; color: var(--text); }
.form-group input[type="text"],
.form-group textarea { width: 100%; max-width: 400px; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 0.9rem; font-family: inherit; background: var(--input-bg); color: var(--text); }
.form-group textarea { resize: vertical; min-height: 60px; }
.range-row { display: flex; align-items: center; gap: 12px; max-width: 400px; }
.range-row input[type="range"] { flex: 1; }
.range-value { font-size: 0.9rem; font-weight: 600; min-width: 24px; text-align: center; }

/* Checkbox */
.checkbox-row { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.85rem; font-weight: 500; }
.checkbox-row input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }

/* Generate button */
.generate-btn { padding: 10px 32px; background: var(--accent); color: #fff; border: none; border-radius: 6px; font-size: 0.95rem; font-weight: 500; cursor: pointer; transition: background 0.15s; }
.generate-btn:hover { background: var(--accent-hover); }
.generate-btn:disabled { background: #999; cursor: not-allowed; }

/* Status text */
.status-text { font-size: 0.85rem; color: var(--text-muted); margin-top: 12px; }
.status-text.error { color: #d32f2f; }

/* Output panel */
.output-area { flex: 1; display: flex; flex-direction: column; }
.output-preview { width: 100%; max-width: 400px; aspect-ratio: 1; background: var(--preview-bg); border: 2px solid var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin-bottom: 12px; position: relative; }
.output-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }
.overlay-img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; pointer-events: none; opacity: 0; }

/* Overlay controls */
.overlay-controls { width: 100%; max-width: 400px; margin-bottom: 12px; display: none; }
.overlay-controls.active { display: block; }
.overlay-controls label { font-size: 0.85rem; font-weight: 500; margin-bottom: 4px; display: block; color: var(--text); }

/* Variations strip */
.variations-strip { width: 100%; margin-bottom: 12px; display: none; }
.variations-strip.active { display: block; }
.variations-strip .section-label { margin-bottom: 6px; }
.variations-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
.variations-header .section-label { margin-bottom: 0; }
.variations-spinner { font-size: 0.8rem; color: var(--text-muted); }
.variations-scroll { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
.variations-thumb { aspect-ratio: 1; border-radius: 4px; border: 2px solid var(--border);
  overflow: hidden; cursor: pointer; transition: border-color 0.15s; position: relative; }
.variations-thumb:hover { border-color: var(--accent); }
.variations-thumb.selected { border-color: var(--accent); border-width: 3px; }
.variations-thumb img { width: 100%; height: 100%; object-fit: cover; }
.variations-thumb.pending { display: flex; align-items: center; justify-content: center;
  background: var(--preview-bg); }
.variations-thumb.pending::after { content: ''; width: 16px; height: 16px; border: 2px solid var(--text-muted);
  border-top-color: var(--accent); border-radius: 50%; animation: varspin 0.8s linear infinite; }
@keyframes varspin { to { transform: rotate(360deg); } }

/* Progress bar */
.progress-bar-container { width: 100%; max-width: 400px; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; margin-bottom: 8px; display: none; }
.progress-bar-container.active { display: block; }
.progress-bar-fill { height: 100%; background: var(--accent); border-radius: 3px; transition: width 0.4s ease; width: 0%; }

/* History strip */
.history-strip { border-top: 1px solid var(--border); background: var(--panel-bg); padding: 12px 24px; }
.history-strip .section-label { margin-bottom: 8px; }
.history-scroll { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px; }
.history-thumb { width: 64px; height: 64px; border-radius: 4px; border: 2px solid var(--border); overflow: hidden; cursor: pointer; flex-shrink: 0; transition: border-color 0.15s; }
.history-thumb:hover { border-color: var(--accent); }
.history-thumb img { width: 100%; height: 100%; object-fit: cover; }
.history-empty { color: var(--text-muted); font-size: 0.85rem; }

/* Lightbox overlay */
.lightbox { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 100; cursor: pointer; }
.lightbox img { max-width: 80vw; max-height: 90vh; object-fit: contain; border-radius: 8px; }
.lightbox-nav { position: absolute; top: 50%; transform: translateY(-50%); width: 48px; height: 48px;
  background: rgba(255,255,255,0.15); border: none; border-radius: 50%; color: #fff; font-size: 1.5rem;
  cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.15s; }
.lightbox-nav:hover { background: rgba(255,255,255,0.3); }
.lightbox-nav.prev { left: 16px; }
.lightbox-nav.next { right: 16px; }
.lightbox-counter { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.6); font-size: 0.8rem; }

/* Live Sketch canvas */
.canvas-wrapper { width: 100%; max-width: 400px; margin-bottom: 12px; position: relative; }
.canvas-wrapper canvas { width: 100%; aspect-ratio: 1; border: 2px solid var(--border); border-radius: 8px; cursor: crosshair; touch-action: none; display: block; background-image: repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%); background-size: 16px 16px; }
body.dark .canvas-wrapper canvas { background-image: repeating-conic-gradient(#444 0% 25%, #333 0% 50%); }
.canvas-overlay-img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; pointer-events: none; border-radius: 8px; opacity: 0.2; display: none; }
.canvas-toolbar { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; max-width: 400px; }
.tool-btn { padding: 6px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--input-bg); color: var(--text); cursor: pointer; font-size: 0.8rem; transition: all 0.15s; }
.tool-btn:hover { border-color: var(--text-muted); background: var(--preview-bg); }
.tool-btn.active { border-color: var(--accent); background: var(--accent); color: #fff; }
.canvas-toolbar .range-row { flex: 1; min-width: 120px; }
.queue-status { font-size: 0.8rem; color: var(--text-muted); margin-top: 4px; }

/* Context menu */
.ctx-menu { position: fixed; z-index: 200; background: var(--panel-bg); border: 1px solid var(--border);
  border-radius: 6px; padding: 4px 0; box-shadow: 0 4px 16px rgba(0,0,0,0.2); min-width: 180px; }
.ctx-menu-item { padding: 8px 16px; font-size: 0.85rem; cursor: pointer; color: var(--text); }
.ctx-menu-item:hover { background: var(--preview-bg); }

/* Confirm modal */
.confirm-modal { position: fixed; inset: 0; z-index: 300; background: rgba(0,0,0,0.5);
  display: flex; align-items: center; justify-content: center; }
.confirm-dialog { background: var(--panel-bg); border: 1px solid var(--border); border-radius: 8px;
  padding: 24px; max-width: 360px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
.confirm-dialog p { font-size: 0.95rem; margin-bottom: 8px; color: var(--text); }
.confirm-dialog .confirm-preview { width: 100%; aspect-ratio: 1; max-width: 200px; border-radius: 6px;
  border: 1px solid var(--border); object-fit: cover; margin: 12px auto; display: block; }
.confirm-dialog .confirm-buttons { display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px; }
.confirm-dialog .confirm-btn { padding: 8px 20px; border-radius: 6px; font-size: 0.85rem; font-weight: 500; cursor: pointer; border: 1px solid var(--border); }
.confirm-dialog .confirm-btn.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
.confirm-dialog .confirm-btn.primary:hover { background: var(--accent-hover); }
.confirm-dialog .confirm-btn.secondary { background: var(--input-bg); color: var(--text); }
.confirm-dialog .confirm-btn.secondary:hover { background: var(--preview-bg); }

/* Image info */
.img-info { font-family: Verdana, sans-serif; font-size: 0.65rem; color: var(--text-muted); margin-bottom: 6px; min-height: 1em; }

/* Sessions modal */
.sessions-modal { position: fixed; inset: 0; z-index: 300; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; }
.sessions-dialog { background: var(--panel-bg); border: 1px solid var(--border); border-radius: 8px; width: 90%; max-width: 520px; max-height: 80vh; overflow-y: auto; padding: 24px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
.sessions-dialog h2 { font-size: 1rem; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center; }
.sessions-close { background: none; border: none; font-size: 1.3rem; cursor: pointer; color: var(--text-muted); padding: 0 4px; line-height: 1; }
.sessions-close:hover { color: var(--text); }
.session-row { border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; overflow: hidden; }
.session-header { padding: 10px 14px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; user-select: none; }
.session-header:hover { background: var(--preview-bg); }
.session-header .session-arrow { margin-right: 8px; display: inline-block; transition: transform 0.15s; font-size: 0.7rem; }
.session-header .session-arrow.open { transform: rotate(90deg); }
.session-body { padding: 10px 14px; border-top: 1px solid var(--border); display: none; }
.session-body.open { display: block; }
.session-thumbs { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 10px; }
.session-thumbs img { width: 56px; height: 56px; object-fit: cover; border-radius: 4px; border: 1px solid var(--border); cursor: pointer; }
.session-actions { display: flex; gap: 8px; }
.session-actions button { padding: 6px 14px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; border: 1px solid var(--border); }
.session-actions .dl-zip { background: var(--accent); color: #fff; border-color: var(--accent); }
.session-actions .dl-zip:hover { background: var(--accent-hover); }
.session-actions .del-session { background: var(--input-bg); color: #d32f2f; border-color: #d32f2f; }
.session-actions .del-session:hover { background: #fdecea; }
body.dark .session-actions .del-session:hover { background: #3a2020; }

/* Responsive */
@media (max-width: 768px) {
  main { flex-direction: column; }
  .panel-left { border-right: none; border-bottom: 1px solid var(--border); }
  .preview-container, .output-preview, .form-group input, .form-group textarea, .canvas-wrapper { max-width: 100%; }
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>

<header>
  <h1>Pencil Flux Klein</h1>
  <div class="header-right">
    <div class="gpu-stats" id="gpuStats">
      <span class="gpu-label">VRAM</span>
      <div class="gpu-bar"><div class="gpu-bar-fill" id="gpuBarFill"></div></div>
      <span class="gpu-text" id="gpuText">--</span>
      <span class="gpu-label" id="gpuJobs"></span>
    </div>
    <button class="theme-toggle" id="sessionsBtn" title="Sessions">Sessions</button>
    <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">&#9790;</button>
    <div class="health-indicator">
      <span class="status-dot disconnected" id="healthDot"></span>
      <span id="healthText">Checking...</span>
    </div>
  </div>
</header>

<main>
  <div class="panel panel-left">
    <div class="section-label">Input Sketch</div>

    <div class="mode-tabs">
      <button class="mode-tab active" data-mode="presets">Presets</button>
      <button class="mode-tab" data-mode="upload">Upload</button>
      <button class="mode-tab" data-mode="live">Live Sketch</button>
    </div>

    <!-- Presets mode -->
    <div class="mode-content active" id="modePresets">
      <div class="preview-container" id="sketchPreview">
        <span class="preview-placeholder">Select a sketch below</span>
      </div>
      <div class="img-info" id="presetImgInfo"></div>
      <div class="sketch-presets" id="sketchPresets">
        <!-- Populated by JS -->
      </div>
    </div>

    <!-- Upload mode -->
    <div class="mode-content" id="modeUpload">
      <div class="preview-container" id="uploadPreview">
        <span class="preview-placeholder">Upload an image</span>
      </div>
      <div class="img-info" id="uploadImgInfo"></div>
      <div class="upload-area">
        <button class="upload-btn" id="uploadBtn">
          Choose file...
          <input type="file" id="fileInput" accept="image/*">
        </button>
      </div>
    </div>

    <!-- Live Sketch mode -->
    <div class="mode-content" id="modeLive">
      <div class="canvas-wrapper">
        <canvas id="sketchCanvas" width="512" height="512"></canvas>
        <img class="canvas-overlay-img" id="canvasOverlayImg" alt="">
      </div>
      <div class="canvas-toolbar">
        <button class="tool-btn active" id="pencilBtn" data-tool="pencil">Pencil</button>
        <button class="tool-btn" id="eraserBtn" data-tool="eraser">Eraser</button>
        <div class="range-row">
          <input type="range" id="strokeWidthInput" min="1" max="30" value="3">
          <span class="range-value" id="strokeWidthValue">3</span>
        </div>
        <button class="tool-btn" id="clearCanvasBtn">Clear</button>
        <button class="tool-btn" id="saveSketchBtn">Save</button>
        <button class="tool-btn" id="loadSketchBtn">Load
          <input type="file" id="loadSketchInput" accept="image/*" style="position:absolute;inset:0;opacity:0;cursor:pointer;">
        </button>
        <span style="width:1px;height:20px;background:var(--border);margin:0 2px"></span>
        <button class="tool-btn" id="fitStretchBtn" data-fit="stretch">Stretch</button>
        <button class="tool-btn active" id="fitFillBtn" data-fit="fill">Fill</button>
        <button class="tool-btn" id="fitFitBtn" data-fit="fit">Fit</button>
      </div>
      <div class="form-group" id="canvasOverlayControls" style="display:none">
        <label>Result overlay</label>
        <div class="range-row">
          <input type="range" id="canvasOverlayOpacity" min="0" max="100" value="20">
          <span class="range-value" id="canvasOverlayOpacityValue">20%</span>
        </div>
      </div>
      <div class="img-info" id="canvasImgInfo"></div>
      <div class="queue-status" id="queueStatus"></div>
    </div>

    <!-- Prompt (always visible) -->
    <div class="form-group">
      <label for="promptInput">Prompt</label>
      <textarea id="promptInput" placeholder="Describe the image you want..."></textarea>
    </div>

    <!-- Creativity slider (always visible) -->
    <div class="form-group">
      <label>Creativity (low = faithful to sketch, high = more creative)</label>
      <div class="range-row">
        <input type="range" id="denoiseInput" min="0" max="100" value="75" step="5">
        <span class="range-value" id="denoiseValue">0.75</span>
      </div>
      <div id="creativityRangeInfo" style="display:none;font-size:0.75rem;color:var(--text-muted);margin-top:4px;align-items:center;gap:8px">
        <span id="creativityRangeText"></span>
        <button class="tool-btn" id="creativityResetBtn" style="padding:2px 8px;font-size:0.7rem">Reset range</button>
      </div>
    </div>

    <!-- Shared controls (hidden in live mode) -->
    <div id="sharedControls">
      <div class="form-group">
        <label>Steps</label>
        <div class="range-row">
          <input type="range" id="stepsInput" min="1" max="50" value="4">
          <span class="range-value" id="stepsValue">4</span>
        </div>
      </div>

      <div class="form-group" id="hdGroup">
        <label class="checkbox-row">
          <input type="checkbox" id="hdToggle">
          <span>HD mode <small style="color:var(--text-muted)">(two-pass: 512 then upscale to 1024)</small></span>
        </label>
      </div>

      <button class="generate-btn" id="generateBtn" disabled>Generate</button>
      <div class="status-text" id="statusText"></div>
    </div>
  </div>

  <div class="panel panel-right">
    <div class="section-label">Output</div>
    <div class="mode-tabs" aria-hidden="true" style="visibility:hidden;pointer-events:none">
      <button class="mode-tab">&nbsp;</button>
    </div>
    <div class="output-area">
      <div class="output-preview" id="outputPreview">
        <span class="preview-placeholder">Result will appear here</span>
      </div>
      <div class="img-info" id="outputImgInfo"></div>
      <div class="overlay-controls" id="overlayControls">
        <label>Sketch overlay</label>
        <div class="range-row">
          <input type="range" id="overlayOpacity" min="0" max="100" value="0">
          <span class="range-value" id="overlayOpacityValue">0%</span>
        </div>
      </div>
      <div class="variations-strip" id="variationsStrip">
        <div class="variations-header">
          <div class="section-label">Variations</div>
          <span class="variations-spinner" id="variationsSpinner"></span>
        </div>
        <div class="variations-scroll" id="variationsScroll"></div>
      </div>
      <div class="progress-bar-container" id="progressBar">
        <div class="progress-bar-fill" id="progressFill"></div>
      </div>
      <div class="status-text" id="outputStatus"></div>
    </div>
  </div>
</main>

<div class="history-strip">
  <div class="section-label">History</div>
  <div class="history-scroll" id="historyScroll">
    <span class="history-empty" id="historyEmpty">No generations yet</span>
  </div>
</div>

<script>
const $ = (sel) => document.querySelector(sel);
const API = '';

// ========================================================================
// State
// ========================================================================
let selectedSketch = null;   // preset id string
let uploadedBase64 = null;   // base64 string for uploaded image
let polling = null;
let currentMode = 'presets'; // 'presets' | 'upload' | 'live'
let fitMode = 'fill'; // 'stretch' | 'fill' | 'fit'
let creativityRange = null; // { min, max } in 0.00–1.00, or null = full range

// Variety batch state
let varietyJobs = [];       // Array of { jobId, status, pollTimer, thumbEl }
const VARIETY_COUNT = 8;
const VARIETY_IDLE_EXTRA = 8;   // Additional variations after idle
const VARIETY_IDLE_MS = 10000;  // 10 seconds idle before extra batch
let varietyIdleTimer = null;
let varietyCapturedInputs = null; // { base64, prompt, steps, denoise } saved from first batch
let varietyBatchGen = 0;         // generation counter — incremented on each new batch

// ========================================================================
// Queue Manager (synced copy of src/queue-manager.ts logic)
// ========================================================================
const MAX_QUEUE = 3;

function createQueue() {
  return { submissions: [], sequenceNumber: 0 };
}

function queueAddSubmission(queue, jobId) {
  queue.sequenceNumber++;
  const entry = { jobId, seqNum: queue.sequenceNumber, status: 'polling', pollTimer: null };
  let evicted = null;
  if (queue.submissions.length >= MAX_QUEUE) {
    queue.submissions.sort((a, b) => a.seqNum - b.seqNum);
    evicted = queue.submissions.shift();
  }
  queue.submissions.push(entry);
  return { entry, evicted };
}

function queueShouldDisplay(queue, entry) {
  if (entry.status !== 'completed') return false;
  return !queue.submissions.some(e => e.seqNum > entry.seqNum && e.status === 'completed');
}

function queueFindEntry(queue, jobId) {
  return queue.submissions.find(e => e.jobId === jobId);
}

function queueActiveCount(queue) {
  return queue.submissions.filter(e => e.status === 'pending' || e.status === 'polling').length;
}

const liveQueue = createQueue();

// ========================================================================
// Canvas Tools (synced copy of src/canvas-tools.ts logic)
// ========================================================================
let toolState = { tool: 'pencil', strokeWidth: 3 };

function getStrokeStyle() {
  return toolState.tool === 'eraser' ? 'destination-out' : 'source-over';
}

function toCanvasCoords(cssX, cssY, cssWidth, cssHeight, canvasWidth, canvasHeight) {
  return { x: (cssX / cssWidth) * canvasWidth, y: (cssY / cssHeight) * canvasHeight };
}

// ========================================================================
// Health check
// ========================================================================
async function checkHealth() {
  try {
    const res = await fetch(`${API}/api/health`);
    const data = await res.json();
    const dot = $('#healthDot');
    const text = $('#healthText');
    if (data.comfyui_reachable) {
      dot.className = 'status-dot connected';
      text.textContent = 'Connected';
    } else {
      dot.className = 'status-dot disconnected';
      text.textContent = 'Disconnected';
    }
  } catch {
    $('#healthDot').className = 'status-dot disconnected';
    $('#healthText').textContent = 'Backend offline';
  }
}

// ========================================================================
// GPU stats polling
// ========================================================================
async function pollGpuStats() {
  try {
    const res = await fetch(`${API}/api/gpu`);
    const data = await res.json();
    const total = data.vram_total;
    const free = data.vram_free;
    const fill = $('#gpuBarFill');
    const text = $('#gpuText');
    const jobsEl = $('#gpuJobs');

    if (total > 0) {
      const usedPct = Math.round(((total - free) / total) * 100);
      const usedGB = ((total - free) / (1024 ** 3)).toFixed(1);
      const totalGB = (total / (1024 ** 3)).toFixed(0);
      fill.style.width = usedPct + '%';
      fill.style.background = usedPct > 90 ? '#f44336' : usedPct > 70 ? '#ff9800' : '#4caf50';
      text.textContent = `${usedGB}/${totalGB}G`;
      text.title = `${data.gpu_name} — ${usedPct}% VRAM used`;
    } else {
      fill.style.width = '0%';
      text.textContent = '--';
      text.title = data.gpu_name;
    }

    if (data.active_jobs > 0) {
      jobsEl.textContent = `${data.active_jobs} job${data.active_jobs > 1 ? 's' : ''}`;
    } else {
      jobsEl.textContent = '';
    }
  } catch {
    $('#gpuBarFill').style.width = '0%';
    $('#gpuText').textContent = '--';
    $('#gpuJobs').textContent = '';
  }
}

// ========================================================================
// Mode tabs
// ========================================================================
document.querySelectorAll('.mode-tab').forEach(tab => {
  tab.addEventListener('click', () => switchMode(tab.dataset.mode));
});

function switchMode(mode) {
  currentMode = mode;
  // Update tab highlight
  document.querySelectorAll('.mode-tab').forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
  // Show/hide mode content
  document.querySelectorAll('.mode-content').forEach(c => c.classList.remove('active'));
  if (mode === 'presets') $('#modePresets').classList.add('active');
  else if (mode === 'upload') $('#modeUpload').classList.add('active');
  else if (mode === 'live') $('#modeLive').classList.add('active');

  // In live mode: hide shared controls (generate btn, HD toggle, etc.)
  const shared = $('#sharedControls');
  if (mode === 'live') {
    shared.style.display = 'none';
  } else {
    shared.style.display = '';
    abortVarietyBatch();
  }

  // Show overlay controls only in live mode
  const overlayCtrl = $('#overlayControls');
  if (mode === 'live') {
    overlayCtrl.classList.add('active');
  } else {
    overlayCtrl.classList.remove('active');
    // Hide canvas overlay when leaving live mode
    if (typeof canvasOverlayImg !== 'undefined') {
      canvasOverlayImg.style.display = 'none';
      $('#canvasOverlayControls').style.display = 'none';
    }
  }
}

// ========================================================================
// Load sketch presets
// ========================================================================
async function loadSketches() {
  try {
    const res = await fetch(`${API}/api/sketches`);
    const sketches = await res.json();
    const container = $('#sketchPresets');
    container.innerHTML = '';

    for (const s of sketches) {
      const btn = document.createElement('button');
      btn.textContent = s.name;
      btn.dataset.id = s.id;
      btn.dataset.prompt = s.default_prompt;
      btn.addEventListener('click', () => selectPreset(s.id, s.default_prompt));
      container.appendChild(btn);
    }
  } catch (e) {
    console.error('Failed to load sketches:', e);
  }
}

async function selectPreset(id, defaultPrompt) {
  selectedSketch = id;
  uploadedBase64 = null;

  // Highlight active button
  document.querySelectorAll('.sketch-presets button').forEach(b => {
    b.classList.toggle('active', b.dataset.id === id);
  });

  // Load preview image
  try {
    const res = await fetch(`${API}/api/sketches/${id}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    showSketchPreview(url);
  } catch (e) {
    console.error('Failed to load sketch:', e);
  }

  // Fill prompt
  $('#promptInput').value = defaultPrompt;
  $('#generateBtn').disabled = false;
}

// ========================================================================
// Upload handling
// ========================================================================
$('#fileInput').addEventListener('change', handleUpload);

function handleUpload(e) {
  const file = e.target.files[0];
  if (!file) return;

  selectedSketch = null;
  document.querySelectorAll('.sketch-presets button').forEach(b => b.classList.remove('active'));

  const reader = new FileReader();
  reader.onload = () => {
    const dataUrl = reader.result;
    uploadedBase64 = dataUrl.split(',')[1];
    // Show in upload preview
    const container = $('#uploadPreview');
    container.innerHTML = '';
    container.classList.add('has-image');
    const img = document.createElement('img');
    img.src = dataUrl;
    img.onload = () => updateImgInfo($('#uploadImgInfo'), img.naturalWidth, img.naturalHeight, file.size);
    container.appendChild(img);
    $('#generateBtn').disabled = false;
  };
  reader.readAsDataURL(file);
}

function showSketchPreview(src) {
  const container = $('#sketchPreview');
  container.innerHTML = '';
  container.classList.add('has-image');
  const img = document.createElement('img');
  img.src = src;
  img.onload = () => updateImgInfoFromUrl(src, img.naturalWidth, img.naturalHeight, '#presetImgInfo');
  container.appendChild(img);
}

// ========================================================================
// Creativity range mapping
// ========================================================================
function getEffectiveRange() {
  if (!creativityRange) return { min: 0, max: 1 };
  const pad = 0.05;
  let min = Math.max(0, creativityRange.min - pad);
  let max = Math.min(1, creativityRange.max + pad);
  if (max - min < 0.10) {
    const mid = (min + max) / 2;
    min = Math.max(0, mid - 0.05);
    max = Math.min(1, mid + 0.05);
  }
  return { min, max };
}

function getDenoiseValue() {
  const slider = parseInt($('#denoiseInput').value) / 100;
  const { min, max } = getEffectiveRange();
  return min + slider * (max - min);
}

function trackCreativity(val) {
  if (!creativityRange) {
    creativityRange = { min: val, max: val };
  } else {
    creativityRange.min = Math.min(creativityRange.min, val);
    creativityRange.max = Math.max(creativityRange.max, val);
  }
  localStorage.setItem('creativityRange', JSON.stringify(creativityRange));
  updateCreativityRangeUI();
}

function updateCreativityRangeUI() {
  const el = $('#creativityRangeInfo');
  if (!creativityRange) {
    el.style.display = 'none';
    return;
  }
  const { min, max } = getEffectiveRange();
  $('#creativityRangeText').textContent = `Slider range: ${min.toFixed(2)} \u2013 ${max.toFixed(2)}`;
  el.style.display = 'flex';
  // Also refresh the displayed value
  $('#denoiseValue').textContent = getDenoiseValue().toFixed(2);
}

// ========================================================================
// Sliders
// ========================================================================
$('#creativityResetBtn').addEventListener('click', () => {
  const currentVal = getDenoiseValue();
  creativityRange = null;
  localStorage.removeItem('creativityRange');
  $('#denoiseInput').value = Math.round(currentVal * 100);
  $('#denoiseValue').textContent = currentVal.toFixed(2);
  updateCreativityRangeUI();
});

$('#stepsInput').addEventListener('input', (e) => {
  $('#stepsValue').textContent = e.target.value;
});
$('#denoiseInput').addEventListener('input', (e) => {
  $('#denoiseValue').textContent = getDenoiseValue().toFixed(2);
  scheduleSubmit();
});
$('#strokeWidthInput').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  toolState.strokeWidth = Math.max(1, Math.min(30, val));
  $('#strokeWidthValue').textContent = toolState.strokeWidth;
});

// ========================================================================
// Progress bar
// ========================================================================
const STATUS_PROGRESS = {
  queued: 10, uploading: 25, submitted: 40, processing: 60, downloading: 85, completed: 100,
};

function setProgress(status) {
  const container = $('#progressBar');
  const fill = $('#progressFill');
  const pct = STATUS_PROGRESS[status];
  if (pct !== undefined) {
    container.classList.add('active');
    fill.style.width = pct + '%';
  }
  if (status === 'completed' || status === 'failed' || status === 'cancelled') {
    // Hide after a short delay so the 100% state is visible
    setTimeout(() => {
      container.classList.remove('active');
      fill.style.width = '0%';
    }, status === 'completed' ? 600 : 0);
  }
}

// ========================================================================
// Generate (presets/upload modes)
// ========================================================================
$('#generateBtn').addEventListener('click', startGeneration);

async function startGeneration() {
  const sketch = uploadedBase64 || selectedSketch;
  if (!sketch) return;

  const prompt = $('#promptInput').value.trim() || undefined;
  const steps = parseInt($('#stepsInput').value);
  const denoise = getDenoiseValue();
  const hd = $('#hdToggle').checked;
  trackCreativity(denoise);

  const btn = $('#generateBtn');
  btn.disabled = true;
  btn.textContent = 'Generating...';
  $('#statusText').textContent = '';
  $('#statusText').className = 'status-text';
  $('#outputStatus').textContent = '';
  $('#outputStatus').className = 'status-text';

  // Clear output and show progress
  setOutputPlaceholder('Generating...');
  setProgress('queued');

  try {
    const res = await fetch(`${API}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sketch, prompt, steps, denoise, hd }),
    });

    if (!res.ok) {
      const err = await res.json();
      throw new Error(err.detail || 'Generation failed');
    }

    const data = await res.json();
    pollJob(data.job_id);
  } catch (e) {
    btn.disabled = false;
    btn.textContent = 'Generate';
    $('#statusText').textContent = `Error: ${e.message}`;
    $('#statusText').className = 'status-text error';
  }
}

function pollJob(jobId) {
  if (polling) clearInterval(polling);

  polling = setInterval(async () => {
    try {
      const res = await fetch(`${API}/api/status/${jobId}`);
      const data = await res.json();
      const elapsed = data.elapsed_seconds ? `${data.elapsed_seconds}s` : '';
      $('#outputStatus').textContent = `Status: ${data.status}${elapsed ? ` (${elapsed})` : ''}`;
      setProgress(data.status);

      if (data.status === 'completed') {
        clearInterval(polling);
        polling = null;
        showResult(jobId, elapsed);
        $('#generateBtn').disabled = false;
        $('#generateBtn').textContent = 'Generate';
      } else if (data.status === 'failed') {
        clearInterval(polling);
        polling = null;
        $('#outputStatus').textContent = `Failed: ${data.error || 'Unknown error'} (${elapsed})`;
        $('#outputStatus').className = 'status-text error';
        setOutputPlaceholder('Generation failed');
        $('#generateBtn').disabled = false;
        $('#generateBtn').textContent = 'Generate';
      }
    } catch (e) {
      clearInterval(polling);
      polling = null;
      $('#outputStatus').textContent = 'Error polling status';
      $('#outputStatus').className = 'status-text error';
      $('#generateBtn').disabled = false;
      $('#generateBtn').textContent = 'Generate';
    }
  }, 1000);
}

async function showResult(jobId, elapsed) {
  try {
    const res = await fetch(`${API}/api/result/${jobId}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    setOutputImage(url);

    $('#outputStatus').textContent = `Completed (${elapsed})`;

    // Add to history
    addToHistory(url);
  } catch (e) {
    $('#outputStatus').textContent = 'Error loading result';
    $('#outputStatus').className = 'status-text error';
  }
}

function addToHistoryDOM(imageUrl) {
  const empty = $('#historyEmpty');
  if (empty) empty.remove();

  const scroll = $('#historyScroll');
  const thumb = document.createElement('div');
  thumb.className = 'history-thumb';
  const img = document.createElement('img');
  img.src = imageUrl;
  thumb.appendChild(img);
  thumb.addEventListener('click', () => openLightbox(imageUrl));
  thumb.addEventListener('contextmenu', (e) => showImageContextMenu(e, imageUrl));
  scroll.prepend(thumb);
}

function addToHistory(imageUrl) {
  addToHistoryDOM(imageUrl);
  // Persist to IndexedDB
  if (db && currentSessionId) {
    fetch(imageUrl).then(r => r.blob()).then(blob => dbSaveImage(blob)).catch(() => {});
  }
}

// ========================================================================
// Context menu + confirm modal for "Use as input sketch"
// ========================================================================
let activeCtxMenu = null;
let ctxMenuDismissHandler = null;

function showImageContextMenu(e, imageUrl) {
  e.preventDefault();
  dismissCtxMenu();

  const menu = document.createElement('div');
  menu.className = 'ctx-menu';

  const item = document.createElement('div');
  item.className = 'ctx-menu-item';
  item.textContent = 'Use as input sketch';
  item.addEventListener('click', () => {
    dismissCtxMenu();
    confirmUseAsSketch(imageUrl);
  });
  menu.appendChild(item);

  // "Cancel all generations" option — show when there are active jobs
  const hasActiveJobs = varietyJobs.some(j => j.status === 'pending' || j.status === 'polling')
    || varietyIdleTimer
    || queueActiveCount(liveQueue) > 0;
  if (hasActiveJobs) {
    const cancelItem = document.createElement('div');
    cancelItem.className = 'ctx-menu-item';
    cancelItem.style.color = '#d32f2f';
    cancelItem.textContent = 'Cancel all generations';
    cancelItem.addEventListener('click', () => {
      dismissCtxMenu();
      abortVarietyBatch();
      // Also cancel live queue jobs
      for (const entry of liveQueue.submissions) {
        if (entry.pollTimer) clearInterval(entry.pollTimer);
        if (entry.status === 'pending' || entry.status === 'polling') {
          fetch(`${API}/api/cancel/${entry.jobId}`, { method: 'POST' }).catch(() => {});
        }
      }
      liveQueue.submissions = [];
      updateQueueStatus();
      setProgress('cancelled');
    });
    menu.appendChild(cancelItem);
  }

  // Position at cursor, clamp to viewport
  menu.style.left = Math.min(e.clientX, window.innerWidth - 200) + 'px';
  menu.style.top = Math.min(e.clientY, window.innerHeight - 50) + 'px';
  document.body.appendChild(menu);
  activeCtxMenu = menu;

  // Dismiss on click elsewhere or Escape
  setTimeout(() => {
    ctxMenuDismissHandler = () => dismissCtxMenu();
    document.addEventListener('click', ctxMenuDismissHandler);
    document.addEventListener('contextmenu', ctxMenuDismissHandler);
  }, 0);
}

function dismissCtxMenu() {
  if (activeCtxMenu) {
    activeCtxMenu.remove();
    activeCtxMenu = null;
  }
  if (ctxMenuDismissHandler) {
    document.removeEventListener('click', ctxMenuDismissHandler);
    document.removeEventListener('contextmenu', ctxMenuDismissHandler);
    ctxMenuDismissHandler = null;
  }
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') dismissCtxMenu();
});

function confirmUseAsSketch(imageUrl) {
  const overlay = document.createElement('div');
  overlay.className = 'confirm-modal';

  const dialog = document.createElement('div');
  dialog.className = 'confirm-dialog';
  dialog.innerHTML = `
    <p><strong>Use as input sketch?</strong></p>
    <p style="font-size:0.8rem;color:var(--text-muted)">This will replace the current canvas and switch to Live Sketch mode.</p>
    <img class="confirm-preview" src="${imageUrl}" alt="Preview">
    <div class="confirm-buttons">
      <button class="confirm-btn secondary" data-action="cancel">Cancel</button>
      <button class="confirm-btn primary" data-action="confirm">Use as sketch</button>
    </div>
  `;
  overlay.appendChild(dialog);
  document.body.appendChild(overlay);

  // Close on backdrop click
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });

  dialog.querySelector('[data-action="cancel"]').addEventListener('click', () => overlay.remove());
  dialog.querySelector('[data-action="confirm"]').addEventListener('click', () => {
    overlay.remove();
    applyAsSketchInput(imageUrl);
  });

  // Escape to close
  const onKey = (e) => { if (e.key === 'Escape') { overlay.remove(); document.removeEventListener('keydown', onKey); } };
  document.addEventListener('keydown', onKey);
}

function applyAsSketchInput(imageUrl) {
  const img = new Image();
  img.onload = () => {
    drawImageToCanvas(img);
    hasStrokes = true;
    switchMode('live');
    updateOverlayImage();
    updateCanvasImgInfo();
    scheduleSubmit();
  };
  img.src = imageUrl;
}

function getHistoryUrls() {
  return Array.from($('#historyScroll').querySelectorAll('.history-thumb img')).map(img => img.src);
}

function openLightbox(src) {
  const urls = getHistoryUrls();
  let idx = urls.indexOf(src);
  if (idx < 0) idx = 0;

  const overlay = document.createElement('div');
  overlay.className = 'lightbox';
  const img = document.createElement('img');
  img.src = src;

  const prevBtn = document.createElement('button');
  prevBtn.className = 'lightbox-nav prev';
  prevBtn.innerHTML = '&#8249;';

  const nextBtn = document.createElement('button');
  nextBtn.className = 'lightbox-nav next';
  nextBtn.innerHTML = '&#8250;';

  const counter = document.createElement('div');
  counter.className = 'lightbox-counter';

  overlay.appendChild(img);
  overlay.appendChild(prevBtn);
  overlay.appendChild(nextBtn);
  overlay.appendChild(counter);
  document.body.appendChild(overlay);

  function show(i) {
    idx = (i + urls.length) % urls.length;
    img.src = urls[idx];
    counter.textContent = `${idx + 1} / ${urls.length}`;
  }
  show(idx);

  prevBtn.addEventListener('click', (e) => { e.stopPropagation(); show(idx - 1); });
  nextBtn.addEventListener('click', (e) => { e.stopPropagation(); show(idx + 1); });
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });

  const onKey = (e) => {
    if (e.key === 'ArrowLeft') { show(idx - 1); e.preventDefault(); }
    else if (e.key === 'ArrowRight') { show(idx + 1); e.preventDefault(); }
    else if (e.key === 'Escape') { overlay.remove(); document.removeEventListener('keydown', onKey); }
  };
  document.addEventListener('keydown', onKey);
}

// ========================================================================
// Canvas drawing engine
// ========================================================================
const canvas = $('#sketchCanvas');
const ctx = canvas.getContext('2d');
let isDrawing = false;
let debounceTimer = null;
let hasStrokes = false;

// Init canvas to transparent (checkerboard shows through)
ctx.clearRect(0, 0, 512, 512);

// Tool buttons
$('#pencilBtn').addEventListener('click', () => {
  toolState.tool = 'pencil';
  $('#pencilBtn').classList.add('active');
  $('#eraserBtn').classList.remove('active');
});
$('#eraserBtn').addEventListener('click', () => {
  toolState.tool = 'eraser';
  $('#eraserBtn').classList.add('active');
  $('#pencilBtn').classList.remove('active');
});
$('#clearCanvasBtn').addEventListener('click', () => {
  ctx.clearRect(0, 0, 512, 512);
  hasStrokes = false;
  updateQueueStatus();
  updateOverlayImage();
  canvasOverlayImg.style.display = 'none';
  $('#canvasOverlayControls').style.display = 'none';
  abortVarietyBatch();
});

// Save sketch to disk
$('#saveSketchBtn').addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = 'sketch.png';
  link.href = canvasToWhiteBgDataURL();
  link.click();
});

// Fit-mode buttons
document.querySelectorAll('[data-fit]').forEach(btn => {
  btn.addEventListener('click', () => {
    fitMode = btn.dataset.fit;
    document.querySelectorAll('[data-fit]').forEach(b => b.classList.toggle('active', b.dataset.fit === fitMode));
  });
});

// Draw an image to the canvas respecting current fitMode
function drawImageToCanvas(img) {
  const cw = 512, ch = 512;
  ctx.clearRect(0, 0, cw, ch);

  if (fitMode === 'stretch') {
    ctx.drawImage(img, 0, 0, cw, ch);
  } else if (fitMode === 'fill') {
    const scale = Math.max(cw / img.width, ch / img.height);
    const sw = cw / scale, sh = ch / scale;
    const sx = (img.width - sw) / 2, sy = (img.height - sh) / 2;
    ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);
  } else {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, cw, ch);
    const scale = Math.min(cw / img.width, ch / img.height);
    const dw = img.width * scale, dh = img.height * scale;
    const dx = (cw - dw) / 2, dy = (ch - dh) / 2;
    ctx.drawImage(img, dx, dy, dw, dh);
  }
}

// Load sketch from disk
$('#loadSketchBtn').style.position = 'relative';
$('#loadSketchInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    const img = new Image();
    img.onload = () => {
      drawImageToCanvas(img);
      hasStrokes = true;
      updateOverlayImage();
      updateCanvasImgInfo();
      scheduleSubmit();
    };
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
  e.target.value = ''; // allow re-loading same file
});

function getCanvasPoint(e) {
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;
  if (e.touches) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  return toCanvasCoords(
    clientX - rect.left, clientY - rect.top,
    rect.width, rect.height,
    512, 512
  );
}

function startStroke(e) {
  e.preventDefault();
  isDrawing = true;
  const pt = getCanvasPoint(e);
  ctx.globalCompositeOperation = getStrokeStyle();
  ctx.beginPath();
  ctx.moveTo(pt.x, pt.y);
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = toolState.strokeWidth;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
}

function continueStroke(e) {
  if (!isDrawing) return;
  e.preventDefault();
  const pt = getCanvasPoint(e);
  ctx.lineTo(pt.x, pt.y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(pt.x, pt.y);
}

function endStroke(e) {
  if (!isDrawing) return;
  e.preventDefault();
  isDrawing = false;
  ctx.globalCompositeOperation = 'source-over';
  hasStrokes = true;
  updateOverlayImage();
  updateCanvasImgInfo();
  // Debounce submission
  scheduleSubmit();
}

// Mouse events
canvas.addEventListener('mousedown', startStroke);
canvas.addEventListener('mousemove', continueStroke);
canvas.addEventListener('mouseup', endStroke);
canvas.addEventListener('mouseleave', endStroke);

// Touch events
canvas.addEventListener('touchstart', startStroke, { passive: false });
canvas.addEventListener('touchmove', continueStroke, { passive: false });
canvas.addEventListener('touchend', endStroke, { passive: false });
canvas.addEventListener('touchcancel', endStroke, { passive: false });

// ========================================================================
// Live queue submission
// ========================================================================
function canvasToWhiteBgDataURL() {
  // Composite canvas onto white background for export (transparent = white, not black)
  const tmp = document.createElement('canvas');
  tmp.width = canvas.width;
  tmp.height = canvas.height;
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#ffffff';
  tctx.fillRect(0, 0, tmp.width, tmp.height);
  tctx.drawImage(canvas, 0, 0);
  return tmp.toDataURL('image/png');
}

async function submitCanvasToQueue() {
  // Get canvas as base64 (with white background)
  const dataUrl = canvasToWhiteBgDataURL();
  const base64 = dataUrl.split(',')[1];

  const prompt = $('#promptInput')?.value?.trim() || undefined;
  const steps = parseInt($('#stepsInput').value);
  const denoise = getDenoiseValue();
  trackCreativity(denoise);

  try {
    const res = await fetch(`${API}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sketch: base64, prompt, steps, denoise, hd: false }),
    });

    if (!res.ok) {
      console.error('Live submit failed:', res.status);
      return;
    }

    const data = await res.json();
    const { entry, evicted } = queueAddSubmission(liveQueue, data.job_id);

    // Cancel evicted job (fire-and-forget)
    if (evicted) {
      if (evicted.pollTimer) clearInterval(evicted.pollTimer);
      fetch(`${API}/api/cancel/${evicted.jobId}`, { method: 'POST' }).catch(() => {});
    }

    // Start polling this job
    entry.pollTimer = setInterval(() => pollLiveJob(entry), 1000);
    updateQueueStatus();
  } catch (e) {
    console.error('Live submit error:', e);
  }
}

async function pollLiveJob(entry) {
  try {
    const res = await fetch(`${API}/api/status/${entry.jobId}`);
    const data = await res.json();

    setProgress(data.status);

    if (data.status === 'completed') {
      entry.status = 'completed';
      if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }

      if (queueShouldDisplay(liveQueue, entry)) {
        await showLiveResult(entry.jobId);
      }
      updateQueueStatus();
    } else if (data.status === 'failed' || data.status === 'cancelled') {
      entry.status = data.status;
      if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }
      updateQueueStatus();
    }
  } catch (e) {
    entry.status = 'failed';
    if (entry.pollTimer) { clearInterval(entry.pollTimer); entry.pollTimer = null; }
    updateQueueStatus();
  }
}

async function showLiveResult(jobId) {
  try {
    const res = await fetch(`${API}/api/result/${jobId}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    setOutputImage(url);
    updateCanvasOverlay(url);

    $('#outputStatus').textContent = 'Live result';
    $('#outputStatus').className = 'status-text';

    addToHistory(url);

    // Fire variety batch after first live result
    if (currentMode === 'live') startVarietyBatch();
  } catch (e) {
    console.error('Error loading live result:', e);
  }
}

function updateQueueStatus() {
  const count = queueActiveCount(liveQueue);
  const el = $('#queueStatus');
  if (count > 0) {
    el.textContent = `${count} generation${count > 1 ? 's' : ''} in queue`;
  } else if (hasStrokes) {
    el.textContent = 'Draw to generate';
  } else {
    el.textContent = '';
  }
}

// ========================================================================
// Variety batch manager
// ========================================================================
function startVarietyBatch() {
  abortVarietyBatch();
  varietyBatchGen++;

  // Capture current inputs for this batch (and potential idle extension)
  const dataUrl = canvasToWhiteBgDataURL();
  varietyCapturedInputs = {
    base64: dataUrl.split(',')[1],
    prompt: $('#promptInput')?.value?.trim() || undefined,
    steps: parseInt($('#stepsInput').value),
    denoise: getDenoiseValue(),
  };

  // Show strip and clear contents
  $('#variationsStrip').classList.add('active');
  $('#variationsScroll').innerHTML = '';

  fireVarietyJobs(VARIETY_COUNT);
}

function fireVarietyJobs(count) {
  const { base64, prompt, steps, denoise } = varietyCapturedInputs;
  const scroll = $('#variationsScroll');
  const gen = varietyBatchGen; // capture generation for stale-check

  for (let i = 0; i < count; i++) {
    const thumbEl = document.createElement('div');
    thumbEl.className = 'variations-thumb pending';
    scroll.appendChild(thumbEl);

    const job = { jobId: null, status: 'pending', pollTimer: null, thumbEl };
    varietyJobs.push(job);

    // Fire request — capture job object + generation to detect stale batches
    (async (j) => {
      try {
        const res = await fetch(`${API}/api/generate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sketch: base64, prompt, steps, denoise, hd: false }),
        });
        if (gen !== varietyBatchGen) return; // batch was replaced
        if (!res.ok) {
          j.status = 'failed';
          j.thumbEl.remove();
          updateVarietySpinner();
          return;
        }
        const data = await res.json();
        if (gen !== varietyBatchGen) return; // batch was replaced
        j.jobId = data.job_id;
        j.status = 'polling';
        j.pollTimer = setInterval(() => pollVarietyJob(j, gen), 1000);
      } catch (e) {
        if (gen !== varietyBatchGen) return; // batch was replaced
        j.status = 'failed';
        j.thumbEl.remove();
        updateVarietySpinner();
      }
    })(job);
  }

  updateVarietySpinner();
}

function updateVarietySpinner() {
  const spinner = $('#variationsSpinner');
  const total = varietyJobs.length;
  const completed = varietyJobs.filter(j => j.status === 'completed').length;
  const done = varietyJobs.filter(j => j.status === 'completed' || j.status === 'failed').length;

  if (done >= total) {
    spinner.textContent = '';
    // If first batch just finished and we haven't extended yet, start idle timer
    if (total === VARIETY_COUNT && varietyCapturedInputs) {
      if (varietyIdleTimer) clearTimeout(varietyIdleTimer);
      varietyIdleTimer = setTimeout(() => {
        varietyIdleTimer = null;
        if (varietyJobs.length === VARIETY_COUNT && varietyCapturedInputs) {
          fireVarietyJobs(VARIETY_IDLE_EXTRA);
        }
      }, VARIETY_IDLE_MS);
    }
  } else {
    spinner.textContent = `Generating... ${completed}/${total}`;
  }
}

async function pollVarietyJob(job, gen) {
  // Guard: stop polling if batch was replaced or job already settled
  if (gen !== varietyBatchGen || !job || !job.jobId
      || job.status === 'completed' || job.status === 'failed') {
    if (job && job.pollTimer) { clearInterval(job.pollTimer); job.pollTimer = null; }
    return;
  }

  try {
    const res = await fetch(`${API}/api/status/${job.jobId}`);
    const data = await res.json();

    if (data.status === 'completed') {
      job.status = 'completed';
      if (job.pollTimer) { clearInterval(job.pollTimer); job.pollTimer = null; }

      // Fetch result image
      const imgRes = await fetch(`${API}/api/result/${job.jobId}`);
      const blob = await imgRes.blob();
      const url = URL.createObjectURL(blob);

      // Replace placeholder with image
      job.thumbEl.classList.remove('pending');
      job.thumbEl.innerHTML = '';
      const img = document.createElement('img');
      img.src = url;
      job.thumbEl.appendChild(img);

      // Click handler: show in main output
      job.thumbEl.addEventListener('click', () => {
        setOutputImage(url);
        updateCanvasOverlay(url);
        // Mark selected
        document.querySelectorAll('.variations-thumb').forEach(t => t.classList.remove('selected'));
        job.thumbEl.classList.add('selected');
      });
      job.thumbEl.addEventListener('contextmenu', (e) => showImageContextMenu(e, url));

      addToHistory(url);
      updateVarietySpinner();

    } else if (data.status === 'failed' || data.status === 'cancelled') {
      job.status = 'failed';
      if (job.pollTimer) { clearInterval(job.pollTimer); job.pollTimer = null; }
      job.thumbEl.remove();
      updateVarietySpinner();
    }
  } catch (e) {
    job.status = 'failed';
    if (job.pollTimer) { clearInterval(job.pollTimer); job.pollTimer = null; }
    job.thumbEl.remove();
    updateVarietySpinner();
  }
}

function abortVarietyBatch() {
  if (varietyIdleTimer) { clearTimeout(varietyIdleTimer); varietyIdleTimer = null; }
  for (const job of varietyJobs) {
    if (job.pollTimer) clearInterval(job.pollTimer);
    if (job.jobId && (job.status === 'pending' || job.status === 'polling')) {
      fetch(`${API}/api/cancel/${job.jobId}`, { method: 'POST' }).catch(() => {});
    }
  }
  varietyJobs = [];
  varietyCapturedInputs = null;
  $('#variationsStrip').classList.remove('active');
  $('#variationsScroll').innerHTML = '';
  $('#variationsSpinner').textContent = '';
}

// ========================================================================
// Dark mode toggle
// ========================================================================
(function initTheme() {
  const saved = localStorage.getItem('theme');
  if (saved === 'dark') document.body.classList.add('dark');
  updateThemeIcon();
})();

$('#themeToggle').addEventListener('click', () => {
  document.body.classList.toggle('dark');
  localStorage.setItem('theme', document.body.classList.contains('dark') ? 'dark' : 'light');
  updateThemeIcon();
});

function updateThemeIcon() {
  $('#themeToggle').innerHTML = document.body.classList.contains('dark') ? '&#9788;' : '&#9790;';
}

// ========================================================================
// Output overlay
// ========================================================================
const overlayImg = document.createElement('img');
overlayImg.className = 'overlay-img';
$('#outputPreview').appendChild(overlayImg);

$('#outputPreview').addEventListener('contextmenu', (e) => {
  const img = $('#outputPreview').querySelector('img:not(.overlay-img)');
  if (img && img.src) {
    showImageContextMenu(e, img.src);
  }
});

$('#overlayOpacity').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  overlayImg.style.opacity = val / 100;
  $('#overlayOpacityValue').textContent = val + '%';
});

function updateOverlayImage() {
  overlayImg.src = canvas.toDataURL('image/png');
}

function setOutputImage(url) {
  const container = $('#outputPreview');
  // Remove all children except overlay img
  Array.from(container.children).forEach(child => {
    if (child !== overlayImg) container.removeChild(child);
  });
  const img = document.createElement('img');
  img.src = url;
  img.onload = () => updateImgInfoFromUrl(url, img.naturalWidth, img.naturalHeight, '#outputImgInfo');
  container.insertBefore(img, overlayImg);
}

function setOutputPlaceholder(text) {
  const container = $('#outputPreview');
  Array.from(container.children).forEach(child => {
    if (child !== overlayImg) container.removeChild(child);
  });
  const span = document.createElement('span');
  span.className = 'preview-placeholder';
  span.textContent = text;
  container.insertBefore(span, overlayImg);
}

// ========================================================================
// Canvas overlay (output over input)
// ========================================================================
const canvasOverlayImg = $('#canvasOverlayImg');

$('#canvasOverlayOpacity').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  canvasOverlayImg.style.opacity = val / 100;
  $('#canvasOverlayOpacityValue').textContent = val + '%';
});

function updateCanvasOverlay(url) {
  canvasOverlayImg.src = url;
  canvasOverlayImg.style.display = 'block';
  $('#canvasOverlayControls').style.display = '';
}

// ========================================================================
// Image info display
// ========================================================================
function formatSize(bytes) {
  if (bytes >= 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  return (bytes / 1024).toFixed(1) + ' KB';
}

function updateImgInfo(el, w, h, sizeBytes) {
  if (!el) return;
  el.textContent = `${w}\u00D7${h} px \u2022 ${formatSize(sizeBytes)}`;
}

function updateImgInfoFromUrl(url, w, h, selector) {
  const el = $(selector);
  if (!el) return;
  fetch(url).then(r => r.blob()).then(blob => {
    updateImgInfo(el, w, h, blob.size);
  }).catch(() => {
    el.textContent = `${w}\u00D7${h} px`;
  });
}

function updateCanvasImgInfo() {
  const el = $('#canvasImgInfo');
  if (!el) return;
  canvas.toBlob((blob) => {
    if (blob) updateImgInfo(el, canvas.width, canvas.height, blob.size);
  });
}

// ========================================================================
// Debounced live submit
// ========================================================================
function scheduleSubmit() {
  if (debounceTimer) clearTimeout(debounceTimer);
  abortVarietyBatch();
  debounceTimer = setTimeout(() => {
    if (currentMode === 'live' && hasStrokes) {
      submitCanvasToQueue();
    }
  }, 300);
}

// ========================================================================
// Random prompt words
// ========================================================================
let wordList = [];

async function loadWordList() {
  try {
    const res = await fetch(`${API}/static/words.txt`);
    const text = await res.text();
    wordList = text.split('\n').filter(w => w.trim());
  } catch (e) {
    console.error('Failed to load word list:', e);
  }
}

function randomPrompt(count = 3) {
  if (!wordList.length) return '';
  const words = [];
  for (let i = 0; i < count; i++) {
    words.push(wordList[Math.floor(Math.random() * wordList.length)]);
  }
  return words.join(' ');
}

function initPrompt() {
  const prompt = $('#promptInput');
  if (!prompt.value.trim()) {
    prompt.value = randomPrompt(3);
  }
}

// ========================================================================
// IndexedDB storage layer
// ========================================================================
let db = null;
let currentSessionId = null;

function initDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open('pencilflux', 1);
    req.onupgradeneeded = (e) => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('images')) {
        const store = d.createObjectStore('images', { autoIncrement: true });
        store.createIndex('sessionId', 'sessionId', { unique: false });
      }
      if (!d.objectStoreNames.contains('sessions')) {
        d.createObjectStore('sessions', { keyPath: 'id' });
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => { console.error('IndexedDB error:', e); resolve(null); };
  });
}

function dbSaveImage(blob) {
  if (!db || !currentSessionId) return Promise.resolve();
  return new Promise((resolve) => {
    const tx = db.transaction(['images', 'sessions'], 'readwrite');
    tx.objectStore('images').add({ sessionId: currentSessionId, blob, timestamp: Date.now() });
    // Bump image count on session
    const sessStore = tx.objectStore('sessions');
    const getReq = sessStore.get(currentSessionId);
    getReq.onsuccess = () => {
      const sess = getReq.result;
      if (sess) {
        sess.imageCount = (sess.imageCount || 0) + 1;
        sessStore.put(sess);
      }
    };
    tx.oncomplete = () => resolve();
    tx.onerror = () => resolve();
  });
}

function dbGetSessionImages(sessionId) {
  if (!db) return Promise.resolve([]);
  return new Promise((resolve) => {
    const tx = db.transaction('images', 'readonly');
    const idx = tx.objectStore('images').index('sessionId');
    const req = idx.getAll(sessionId);
    req.onsuccess = () => resolve(req.result.map(r => r.blob));
    req.onerror = () => resolve([]);
  });
}

function dbGetSessions() {
  if (!db) return Promise.resolve([]);
  return new Promise((resolve) => {
    const tx = db.transaction('sessions', 'readonly');
    const req = tx.objectStore('sessions').getAll();
    req.onsuccess = () => {
      const sessions = req.result.sort((a, b) => b.createdAt - a.createdAt);
      resolve(sessions);
    };
    req.onerror = () => resolve([]);
  });
}

function dbDeleteSession(sessionId) {
  if (!db) return Promise.resolve();
  return new Promise((resolve) => {
    const tx = db.transaction(['images', 'sessions'], 'readwrite');
    // Delete all images for this session
    const idx = tx.objectStore('images').index('sessionId');
    const curReq = idx.openCursor(sessionId);
    curReq.onsuccess = (e) => {
      const cursor = e.target.result;
      if (cursor) { cursor.delete(); cursor.continue(); }
    };
    // Delete session record
    tx.objectStore('sessions').delete(sessionId);
    tx.oncomplete = () => resolve();
    tx.onerror = () => resolve();
  });
}

function dbCreateSession(id) {
  if (!db) return Promise.resolve();
  const now = new Date(id);
  const label = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ', ' +
    now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
  return new Promise((resolve) => {
    const tx = db.transaction('sessions', 'readwrite');
    tx.objectStore('sessions').put({ id, label, createdAt: id, imageCount: 0 });
    tx.oncomplete = () => resolve();
    tx.onerror = () => resolve();
  });
}

// ========================================================================
// Sessions modal
// ========================================================================
$('#sessionsBtn').addEventListener('click', openSessionsModal);

async function openSessionsModal() {
  const sessions = await dbGetSessions();

  const overlay = document.createElement('div');
  overlay.className = 'sessions-modal';

  const dialog = document.createElement('div');
  dialog.className = 'sessions-dialog';

  const header = document.createElement('h2');
  header.innerHTML = 'Sessions <button class="sessions-close">&times;</button>';
  dialog.appendChild(header);

  header.querySelector('.sessions-close').addEventListener('click', () => overlay.remove());

  if (sessions.length === 0) {
    const empty = document.createElement('p');
    empty.style.cssText = 'color:var(--text-muted);font-size:0.85rem';
    empty.textContent = 'No sessions yet. Generate some images!';
    dialog.appendChild(empty);
  }

  for (const sess of sessions) {
    const isCurrent = sess.id === currentSessionId;
    const row = document.createElement('div');
    row.className = 'session-row';

    const hdr = document.createElement('div');
    hdr.className = 'session-header';
    const arrow = document.createElement('span');
    arrow.className = 'session-arrow' + (isCurrent ? ' open' : '');
    arrow.textContent = '\u25B6';
    const info = document.createElement('span');
    info.textContent = (isCurrent ? 'Current \u2014 ' : '') + sess.label + ` (${sess.imageCount || 0})`;
    const leftSide = document.createElement('span');
    leftSide.appendChild(arrow);
    leftSide.appendChild(document.createTextNode(' '));
    leftSide.appendChild(info);
    hdr.appendChild(leftSide);
    row.appendChild(hdr);

    const body = document.createElement('div');
    body.className = 'session-body' + (isCurrent ? ' open' : '');
    row.appendChild(body);

    // Toggle expand/collapse
    hdr.addEventListener('click', async () => {
      const isOpen = body.classList.contains('open');
      if (isOpen) {
        body.classList.remove('open');
        arrow.classList.remove('open');
      } else {
        body.classList.add('open');
        arrow.classList.add('open');
        // Load thumbnails if not already loaded
        if (!body.dataset.loaded) {
          body.dataset.loaded = '1';
          await loadSessionThumbs(body, sess.id);
        }
      }
    });

    // Auto-load current session thumbnails
    if (isCurrent) {
      loadSessionThumbs(body, sess.id);
    }

    dialog.appendChild(row);
  }

  overlay.appendChild(dialog);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
  const onKey = (e) => { if (e.key === 'Escape') { overlay.remove(); document.removeEventListener('keydown', onKey); } };
  document.addEventListener('keydown', onKey);
}

async function loadSessionThumbs(body, sessionId) {
  const blobs = await dbGetSessionImages(sessionId);
  body.innerHTML = '';

  const thumbsDiv = document.createElement('div');
  thumbsDiv.className = 'session-thumbs';

  if (blobs.length === 0) {
    const empty = document.createElement('span');
    empty.style.cssText = 'color:var(--text-muted);font-size:0.8rem';
    empty.textContent = 'No images in this session';
    thumbsDiv.appendChild(empty);
  } else {
    for (const blob of blobs) {
      const url = URL.createObjectURL(blob);
      const img = document.createElement('img');
      img.src = url;
      img.addEventListener('click', () => openLightbox(url));
      thumbsDiv.appendChild(img);
    }
  }
  body.appendChild(thumbsDiv);

  const actions = document.createElement('div');
  actions.className = 'session-actions';

  if (blobs.length > 0) {
    const dlBtn = document.createElement('button');
    dlBtn.className = 'dl-zip';
    dlBtn.textContent = 'Download ZIP';
    dlBtn.addEventListener('click', async () => {
      const sess = (await dbGetSessions()).find(s => s.id === sessionId);
      dlBtn.textContent = 'Zipping...';
      dlBtn.disabled = true;
      await downloadSessionZip(sessionId, sess ? sess.label : 'session');
      dlBtn.textContent = 'Download ZIP';
      dlBtn.disabled = false;
    });
    actions.appendChild(dlBtn);
  }

  if (sessionId !== currentSessionId) {
    const delBtn = document.createElement('button');
    delBtn.className = 'del-session';
    delBtn.textContent = 'Delete';
    delBtn.addEventListener('click', async () => {
      if (!confirm('Delete this session and all its images?')) return;
      await dbDeleteSession(sessionId);
      body.parentElement.remove();
    });
    actions.appendChild(delBtn);
  }

  body.appendChild(actions);
}

// ========================================================================
// ZIP download
// ========================================================================
async function downloadSessionZip(sessionId, label) {
  const images = await dbGetSessionImages(sessionId);
  const zip = new JSZip();
  images.forEach((blob, i) => {
    const ext = blob.type === 'image/jpeg' ? 'jpg' : 'png';
    zip.file(`image-${String(i + 1).padStart(3, '0')}.${ext}`, blob);
  });
  const content = await zip.generateAsync({ type: 'blob' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(content);
  a.download = `pencilflux-${label.replace(/[^a-z0-9]/gi, '-')}.zip`;
  a.click();
  URL.revokeObjectURL(a.href);
}

// ========================================================================
// Init
// ========================================================================
checkHealth();
setInterval(checkHealth, 30000);
pollGpuStats();
setInterval(pollGpuStats, 1000);
loadSketches();
loadWordList().then(initPrompt);
// Load saved creativity range
const savedRange = localStorage.getItem('creativityRange');
if (savedRange) { creativityRange = JSON.parse(savedRange); }
updateCreativityRangeUI();
// Default to live sketch mode
switchMode('live');

// Init IndexedDB and session
initDB().then(async () => {
  if (!db) return;
  const sessions = await dbGetSessions();
  const recent = sessions[0];
  const ONE_HOUR = 60 * 60 * 1000;
  if (recent && Date.now() - recent.createdAt < ONE_HOUR) {
    currentSessionId = recent.id;
    // Repopulate history strip from stored blobs
    const blobs = await dbGetSessionImages(currentSessionId);
    for (const blob of blobs) {
      const url = URL.createObjectURL(blob);
      addToHistoryDOM(url);
    }
  } else {
    currentSessionId = Date.now();
    await dbCreateSession(currentSessionId);
  }
});
</script>
</body>
</html>
